<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Galaxy - Hyper Cosmic</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Times New Roman', serif; transition: cursor 0.3s; }
        
        body.ui-hidden { cursor: none; } 
        body.ui-hidden #ui-container, 
        body.ui-hidden .btn-group, 
        body.ui-hidden #cam-container {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        #ui-container {
            position: absolute; top: 20px; left: 20px; width: auto; 
            text-align: left; pointer-events: none; z-index: 10; transition: opacity 0.5s;
        }
        
        h1 {
            color: #ffeb3b; font-size: 2.5rem; margin: 0 0 10px 0; letter-spacing: 3px;
            text-shadow: 0 0 10px rgba(255,215,0,0.6), 0 0 20px rgba(255,0,0,0.4); text-transform: uppercase;
        }

        .instructions {
            color: #eee; font-size: 0.95rem; margin-top: 5px; font-family: sans-serif;
            background: rgba(0,0,0,0.6); padding: 20px; border-radius: 15px; display: inline-block;
            border: 1px solid rgba(255,255,255,0.1); line-height: 1.8;
            backdrop-filter: blur(5px);
        }

        .key-point { color: #00ff00; font-weight: bold; text-transform: uppercase; }
        .music-point { color: #00d2ff; font-weight: bold; text-transform: uppercase; border: 1px solid #00d2ff; padding: 2px 6px; border-radius: 4px; }
        
        #music-status-display {
            margin-top: 15px; font-family: monospace; font-size: 1.1rem; color: #00d2ff;
            text-shadow: 0 0 5px #00d2ff; display: block;
            background: rgba(0,0,0,0.8); padding: 8px 15px; border-radius: 5px;
            pointer-events: auto; cursor: pointer; border: 1px solid #00d2ff; width: fit-content;
        }
        #music-status-display:hover { background: rgba(0, 210, 255, 0.2); }

        #cam-container {
            position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px;
            border: 2px solid rgba(255,215,0,0.3); border-radius: 10px; overflow: hidden;
            z-index: 20; background: #000; display: none; transition: opacity 0.5s;
        }
        #webcam_video { position: absolute; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.5; }
        #output_canvas { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }
        
        #gesture-status {
            position: absolute; top: 10px; left: 10px; color: #00ff00; font-weight: bold; font-family: monospace; font-size: 16px;
            text-shadow: 0 0 2px black; z-index: 25;
        }

        .btn-group {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; z-index: 30; pointer-events: auto;
            transition: opacity 0.5s;
        }

        .magic-btn {
            padding: 15px 30px; background: linear-gradient(45deg, #ffd700, #ffaa00);
            border: none; border-radius: 30px; color: #000; font-weight: bold; font-size: 1.1rem;
            cursor: pointer; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); transition: 0.3s;
        }
        .magic-btn:hover { transform: scale(1.05); background: linear-gradient(45deg, #ffaa00, #ffd700); }
        .magic-btn.secondary { background: linear-gradient(45deg, #00d2ff, #3a7bd5); color: white; }
        
        #file-input-photo { display: none; }
        #file-input-music { display: none; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-container">
        <h1>Christmas Galaxy</h1>
        <div class="instructions">
            üëã <span class="key-point">Swipe</span>: ËΩ¨Âä®<br>
            üñêÔ∏è <span class="key-point">Open</span>: ÁàÜÁÇ∏<br>
            ‚úä <span class="key-point">Fist</span>: Âú£ËØûÊ†ë<br>
            ‚òùÔ∏è <span class="key-point">Point</span>: ÊñáÂ≠óÊ®°Âºè</b><br>
            ü§è <span class="key-point">Pinch</span>: ÂõæÁâáÊîæÂ§ß<br>
            ‚úåÔ∏è <span class="key-point">Victory</span>: Êç¢È¢úËâ≤<br>
            <br>
            <span class="music-point">SPACE</span>: ‰∏ã‰∏ÄÈ¶ñ &nbsp;
            <span class="fs-point">F</span>: ÂÖ®Â±è
        </div>
        <div id="music-status-display" title="Click to Toggle">üéµ Music: Waiting...</div>
    </div>

    <div class="btn-group">
        <label for="file-input-photo" class="magic-btn secondary">üìÇ ÈÄâÊã©ÁÖßÁâá</label>
        <input type="file" id="file-input-photo" multiple accept="image/*" webkitdirectory>

        <label for="file-input-music" class="magic-btn secondary">üéµ Ëá™ÂÆö‰πâËÉåÊôØÈü≥‰πê</label>
        <input type="file" id="file-input-music" accept="audio/*">

        <button id="start-btn" class="magic-btn">üì∏ ÂºÄÂßã</button>
    </div>

    <div id="cam-container">
        <video id="webcam_video"></video>
        <canvas id="output_canvas"></canvas>
        <div id="gesture-status">System Ready</div>
    </div>

    <audio id="bg-music" preload="auto"></audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

        // --- 0. Èü≥‰πêÁ≥ªÁªü ---
        const PLAYLIST = [
            { title: "Jingle Bells", src: "https://incompetech.com/music/royalty-free/mp3-royaltyfree/Jingle%20Bells.mp3" },
            { title: "We Wish You a Merry Christmas", src: "https://incompetech.com/music/royalty-free/mp3-royaltyfree/We%20Wish%20you%20a%20Merry%20Christmas.mp3" },
            { title: "Deck the Halls", src: "https://incompetech.com/music/royalty-free/mp3-royaltyfree/Deck%20the%20Halls%20B.mp3" },
            { title: "Silent Night", src: "https://incompetech.com/music/royalty-free/mp3-royaltyfree/Silent%20Night.mp3" }
        ];
        
        let currentSongIndex = 0;
        const audioEl = document.getElementById('bg-music');
        const musicDisplay = document.getElementById('music-status-display');

        document.getElementById('file-input-music').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                PLAYLIST.unshift({ title: "üìÅ Custom: " + file.name, src: url });
                playMusic(0);
            }
        });

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'Enter') nextSong();
            if (e.code === 'KeyF') toggleFullscreen();
        });

        function toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e=>console.log(e));
            else if (document.exitFullscreen) document.exitFullscreen();
        }

        document.addEventListener('fullscreenchange', () => {
            document.body.classList.toggle('ui-hidden', !!document.fullscreenElement);
        });

        musicDisplay.addEventListener('click', () => {
            if (audioEl.paused) {
                if (audioEl.src) audioEl.play().catch(e => console.warn(e));
                else playMusic(currentSongIndex);
            } else nextSong();
        });

        audioEl.addEventListener('error', () => {
            musicDisplay.innerText = "‚ùå Network Error (Skip in 2s)";
            musicDisplay.style.color = 'orange';
            setTimeout(() => nextSong(), 2000);
        });

        audioEl.addEventListener('ended', nextSong);

        function playMusic(index) {
            currentSongIndex = (index + PLAYLIST.length) % PLAYLIST.length;
            const song = PLAYLIST[currentSongIndex];
            musicDisplay.style.display = 'block';
            musicDisplay.innerText = `‚åõ Buffering: ${song.title}...`;
            musicDisplay.style.color = '#00d2ff';
            audioEl.src = song.src;
            audioEl.volume = 1.0; 
            audioEl.play().then(() => {
                musicDisplay.innerText = `üéµ Playing: ${song.title}`;
                musicDisplay.style.color = '#00ff00';
            }).catch(() => {
                musicDisplay.innerText = `‚ö†Ô∏è Click Here to Enable Audio`;
                musicDisplay.style.color = 'yellow';
            });
        }
        function nextSong() { playMusic(currentSongIndex + 1); }

        // --- 1. Âú∫ÊôØÈÖçÁΩÆ ---
        const CONFIG = {
            count: 6000,
            radius: 8,       
            height: 25,      
            restoreSpeed: 0.08,
            floatSpeed: 0.05
        };

        const PALETTES = [
            { name: "Classic Gold/Red", gold: 0xFFD700, red: 0xD41E3A, green: 0x005235 }, 
            { name: "Frozen Silver/Blue", gold: 0xE0FFFF, red: 0x4682B4, green: 0x708090 }, 
            { name: "Candy Pop", gold: 0xFF69B4, red: 0x00FFFF, green: 0x9370DB } 
        ];
        let currentPaletteIndex = 0;
        let currentBorderColor = new THREE.Color(PALETTES[0].gold); 

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.010);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 55);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        document.body.appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const mainLight = new THREE.DirectionalLight(0xffeeb1, 2.0);
        mainLight.position.set(0, 50, 20);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);
        camera.add(new THREE.PointLight(0xffffff, 0.8));
        scene.add(camera);

        // --- Ë£ÖÈ•∞ (Decorations) ---
        const decorGroup = new THREE.Group();
        scene.add(decorGroup);

        const spiralGeo = new THREE.BufferGeometry();
        const spiralCount = 600;
        const spiralPos = new Float32Array(spiralCount * 3);
        for(let i=0; i<spiralCount; i++) {
            spiralPos[i*3] = 0; spiralPos[i*3+1] = 0; spiralPos[i*3+2] = 0; 
        }
        spiralGeo.setAttribute('position', new THREE.BufferAttribute(spiralPos, 3));
        const spiralMat = new THREE.PointsMaterial({ 
            color: 0xffaa00, size: 0.4, transparent: true, opacity: 0.6, 
            blending: THREE.AdditiveBlending 
        });
        const spiralSystem = new THREE.Points(spiralGeo, spiralMat);
        decorGroup.add(spiralSystem);

        const ringGeo = new THREE.RingGeometry(8, 9, 64);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xffd700, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
        const floorRing = new THREE.Mesh(ringGeo, ringMat);
        floorRing.rotation.x = -Math.PI / 2;
        floorRing.position.y = -CONFIG.height / 2 - 2;
        decorGroup.add(floorRing);


        // --- 2. Á≤íÂ≠ê‰∏éÂØπË±° ---
        const sphereMaterial = new THREE.MeshStandardMaterial({ metalness: 0.8, roughness: 0.2 });
        const cubeMaterial = new THREE.MeshStandardMaterial({ metalness: 0.7, roughness: 0.4 });
        const sphereMesh = new THREE.InstancedMesh(new THREE.SphereGeometry(0.35, 12, 12), sphereMaterial, CONFIG.count);
        const cubeMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), cubeMaterial, CONFIG.count);
        sphereMesh.castShadow = true; sphereMesh.receiveShadow = true;
        cubeMesh.castShadow = true; cubeMesh.receiveShadow = true;
        
        const treeGroup = new THREE.Group();
        treeGroup.add(sphereMesh);
        treeGroup.add(cubeMesh);
        scene.add(treeGroup);

        const topperMat = new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xffaa00, emissiveIntensity: 1 });
        const topperMesh = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), topperMat);
        treeGroup.add(topperMesh);

        // ÊòüÁöÑËøêÂä®Áä∂ÊÄÅ
        const topperState = {
            posTree: new THREE.Vector3(0, CONFIG.height/2+1.5, 0), 
            posCloud: new THREE.Vector3(0, 20, 0), 
            posText: new THREE.Vector3(0, 8, 0),   
            currentPos: new THREE.Vector3(0, CONFIG.height/2+1.5, 0),
            targetPos: new THREE.Vector3(0, CONFIG.height/2+1.5, 0),
            floatOffset: 0
        };

        const instances = [];
        const photoInstances = [];
        const dummy = new THREE.Object3D();
        const _color = new THREE.Color();

        function getTreePos(i, total) {
            const ratio = i / total;
            const y = ratio * CONFIG.height - CONFIG.height/2;
            const r = Math.pow((1-ratio), 0.9) * CONFIG.radius;
            const angle = i * 137.5;
            const rad = Math.sqrt(Math.random()) * r;
            return new THREE.Vector3(Math.cos(angle)*rad, y, Math.sin(angle)*rad);
        }

        function getCloudPos() {
            return new THREE.Vector3(
                (Math.random() - 0.5) * 180, 
                (Math.random() - 0.5) * 100, 
                (Math.random() - 0.5) * 100 
            );
        }

        function getSafeZonePos() {
            return new THREE.Vector3(
                (Math.random() - 0.5) * 50, 
                (Math.random() - 0.5) * 30, 
                (Math.random() - 0.5) * 20  
            );
        }

        // ====================================================
        // --- NEW: Ë∂ÖÊó∂Á©∫ÊòüÂ∞òÈ£éÊö¥ (Hyper Cosmic Storm) ---
        // ====================================================
        
        // 1. ÁîüÊàêÊüîÂíåÂÖâÁÇπÊùêË¥®
        const glowCanvas = document.createElement('canvas');
        glowCanvas.width = 32; glowCanvas.height = 32;
        const ctx = glowCanvas.getContext('2d');
        const grd = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grd.addColorStop(0, 'rgba(255, 255, 255, 1)');
        grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grd; ctx.fillRect(0, 0, 32, 32);
        const glowTex = new THREE.CanvasTexture(glowCanvas);

        // 2. ÊòüÂ∞òÁ≥ªÁªü (ÂÖ®Â±èË¶ÜÁõñ)
        const galaxyGeo = new THREE.BufferGeometry();
        const galaxyCount = 3000;
        const galaxyPos = new Float32Array(galaxyCount * 3);
        const galaxySizes = new Float32Array(galaxyCount);
        
        for(let i=0; i<galaxyCount; i++) {
            // Âú®Â∑®Â§ßÁöÑÁêÉ‰ΩìÂÜÖÈöèÊú∫ÂàÜÂ∏É (Radius 150)
            // ÊëÑÂÉèÊú∫Âú® Z=55ÔºåÊâÄ‰ª•ËåÉÂõ¥Ë¶ÅÊ∂µÁõñÂπ∂Ë∂ÖË∂äÊëÑÂÉèÊú∫
            const r = Math.random() * 150; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            galaxyPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
            galaxyPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            galaxyPos[i*3+2] = r * Math.cos(phi);
            
            // ÈöèÊú∫Â§ßÂ∞èÔºåÂà∂ÈÄ†ÊôØÊ∑±ÊÑü
            galaxySizes[i] = Math.random() * 1.5 + 0.5;
        }
        galaxyGeo.setAttribute('position', new THREE.BufferAttribute(galaxyPos, 3));
        galaxyGeo.setAttribute('size', new THREE.BufferAttribute(galaxySizes, 1));
        
        const galaxyMat = new THREE.PointsMaterial({
            color: 0xffcc00, 
            size: 1.0, 
            map: glowTex,
            transparent: true, opacity: 0, 
            depthWrite: false, 
            blending: THREE.AdditiveBlending
        });
        const galaxySystem = new THREE.Points(galaxyGeo, galaxyMat);
        scene.add(galaxySystem);

        // 3. ÊµÅÊòüÈõ® (Shooting Lines) - Â¢ûÂä†ÈÄüÂ∫¶ÊÑü
        const lineGeo = new THREE.BufferGeometry();
        const lineCount = 150;
        const linePos = [];
        const lineSpeed = [];
        
        for(let i=0; i<lineCount; i++) {
            // ÈöèÊú∫Ëµ∑ÁÇπ
            const x = (Math.random()-0.5) * 300;
            const y = (Math.random()-0.5) * 300;
            const z = (Math.random()-0.5) * 300;
            // ÊØèÊù°Á∫ø‰∏§‰∏™ÁÇπ
            linePos.push(x, y, z);
            linePos.push(x, y - 5, z); // Â∞æÂ∑¥ÈïøÂ∫¶
            lineSpeed.push((Math.random() + 0.5) * 2); // ÈÄüÂ∫¶
        }
        lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
        const lineMat = new THREE.LineBasicMaterial({
            color: 0xffffff, transparent: true, opacity: 0, blending: THREE.AdditiveBlending
        });
        const shootingLines = new THREE.LineSegments(lineGeo, lineMat);
        scene.add(shootingLines);


        // --- 4. Èõ™Ëä±Á≥ªÁªü ---
        const snowGeo = new THREE.BufferGeometry();
        const snowCount = 1500;
        const snowPos = new Float32Array(snowCount * 3);
        const snowVel = []; 
        for(let i=0; i<snowCount; i++) {
            snowPos[i*3] = (Math.random()-0.5) * 100;
            snowPos[i*3+1] = (Math.random()-0.5) * 60;
            snowPos[i*3+2] = (Math.random()-0.5) * 50 + 20;
            snowVel.push({
                x: (Math.random()-0.5)*0.05,
                y: -(Math.random()*0.1 + 0.05),
                z: (Math.random()-0.5)*0.05
            });
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        const snowTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/snowflake1.png');
        const snowMat = new THREE.PointsMaterial({
            color: 0xffffff, size: 0.8, map: snowTexture, 
            transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending
        });
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);

        // --- 5. ÊñáÂ≠óÁîüÊàêÈÄªËæë ---
        let textPoints = [];
        const fontLoader = new FontLoader();
        fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
            
            const geo1 = new TextGeometry('MERRY', { font: font, size: 5, height: 0.2, curveSegments: 6, bevelEnabled: false });
            geo1.center(); 
            const mesh1 = new THREE.Mesh(geo1, new THREE.MeshBasicMaterial());
            mesh1.position.y = 3.2; 
            mesh1.updateMatrixWorld();

            const geo2 = new TextGeometry('CHRISTMAS', { font: font, size: 5, height: 0.2, curveSegments: 6, bevelEnabled: false });
            geo2.center(); 
            const mesh2 = new THREE.Mesh(geo2, new THREE.MeshBasicMaterial());
            mesh2.position.y = -3.2; 
            mesh2.updateMatrixWorld();

            const sampler1 = new MeshSurfaceSampler(mesh1).build();
            const sampler2 = new MeshSurfaceSampler(mesh2).build();
            
            textPoints = [];
            const tempPos = new THREE.Vector3();
            const tempTarget = new THREE.Vector3();

            const halfCount = Math.floor(CONFIG.count / 2);
            for (let i = 0; i < CONFIG.count; i++) {
                if (i < halfCount) {
                    sampler1.sample(tempPos);
                    tempTarget.copy(tempPos).applyMatrix4(mesh1.matrixWorld);
                } else {
                    sampler2.sample(tempPos);
                    tempTarget.copy(tempPos).applyMatrix4(mesh2.matrixWorld);
                }
                textPoints.push(new THREE.Vector3(tempTarget.x, tempTarget.y, 0));
            }
            
            instances.forEach((inst, i) => {
                if (textPoints[i]) inst.posText = textPoints[i];
                else inst.posText = inst.posTree; 
            });
            console.log("Text Geometry Loaded");
        });

        // --- ÂàùÂßãÂåñÁ≤íÂ≠ê ---
        let sIdx=0, cIdx=0;
        for(let i=0; i<CONFIG.count; i++) {
            const isSphere = Math.random()>0.5;
            const mesh = isSphere ? sphereMesh : cubeMesh;
            const idx = isSphere ? sIdx++ : cIdx++;
            
            const treePos = getTreePos(i, CONFIG.count);
            const cloudPos = getCloudPos(); 
            
            instances.push({
                type: isSphere ? 'sphere' : 'cube',
                meshIndex: idx,
                targetPos: treePos, 
                posTree: treePos,  
                posCloud: cloudPos,
                posText: cloudPos, 
                currentPos: treePos.clone(),
                rotSpeed: {x:(Math.random()-0.5)*0.05, y:(Math.random()-0.5)*0.05},
                rotation: new THREE.Euler(Math.random()*6, Math.random()*6, 0)
            });
            
            dummy.position.copy(treePos);
            dummy.scale.setScalar(0.5 + Math.random());
            dummy.updateMatrix();
            mesh.setMatrixAt(idx, dummy.matrix);
        }

        function applyColors(paletteIdx) {
            const p = PALETTES[paletteIdx];
            currentBorderColor.setHex(p.gold); 
            topperMat.color.setHex(p.gold);
            topperMat.emissive.setHex(p.red); 
            
            spiralMat.color.setHex(p.gold);
            floorRing.material.color.setHex(p.gold);
            
            // ÊòüÂ∞òÈ¢úËâ≤ËÅîÂä®
            galaxyMat.color.setHex(p.gold);
            lineMat.color.setHex(p.gold);

            photoInstances.forEach(inst => {
                if(inst.mesh.material) inst.mesh.material.color.setHex(p.gold); 
            });

            for(let i=0; i<CONFIG.count; i++) {
                const isSphere = instances[i].type === 'sphere';
                if(isSphere) _color.setHex(Math.random()>0.3 ? p.gold : p.red);
                else _color.setHex(Math.random()>0.5 ? p.gold : p.green);
                const mesh = isSphere ? sphereMesh : cubeMesh;
                mesh.setColorAt(instances[i].meshIndex, _color);
            }
            sphereMesh.instanceColor.needsUpdate = true;
            cubeMesh.instanceColor.needsUpdate = true;
        }
        applyColors(0);

        // --- ÁÖßÁâáÂ§ÑÁêÜ ---
        const photoGroup = new THREE.Group();
        scene.add(photoGroup);
        document.getElementById('file-input-photo').addEventListener('change', handleFileSelect);

        function handleFileSelect(event) {
            const files = Array.from(event.target.files).filter(f => f.type.startsWith('image/'));
            if(files.length === 0) return;
            photoInstances.forEach(p => {
                photoGroup.remove(p.mesh);
                p.mesh.geometry.dispose(); p.mesh.material.dispose();
                if (p.mesh.children[0]) { p.mesh.children[0].geometry.dispose(); p.mesh.children[0].material.dispose(); }
            });
            photoInstances.length = 0;

            const loader = new THREE.TextureLoader();
            const photoCount = Math.min(files.length, 60); 
            
            files.slice(0, photoCount).forEach((file, i) => {
                loader.load(URL.createObjectURL(file), (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    const aspect = texture.image.width / texture.image.height;
                    const photoW = 0.8; const photoH = photoW / aspect;
                    
                    const borderMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(photoW+0.06, photoH+0.06, 0.04),
                        new THREE.MeshStandardMaterial({ color: currentBorderColor, roughness: 0.2, metalness: 0.8 })
                    );
                    const photoMesh = new THREE.Mesh(
                        new THREE.PlaneGeometry(photoW, photoH),
                        new THREE.MeshBasicMaterial({ map: texture })
                    );
                    photoMesh.position.z = 0.022;
                    borderMesh.add(photoMesh);

                    const treePos = getTreePos(i, photoCount);
                    treePos.x *= 1.05; treePos.z *= 1.05;

                    const cloudPos = getSafeZonePos(); 
                    
                    borderMesh.position.copy(treePos);
                    borderMesh.lookAt(0, treePos.y, 0); 
                    photoGroup.add(borderMesh);
                    
                    photoInstances.push({
                        mesh: borderMesh,
                        posTree: treePos, 
                        posCloud: cloudPos, 
                        targetPos: treePos, currentPos: treePos.clone(),
                        baseScale: 1.0, currentScale: 1.0,
                        rotationTree: borderMesh.rotation.clone(),
                        rotVelocity: { x: (Math.random()-0.5)*0.03, y: (Math.random()-0.5)*0.03 }
                    });
                });
            });
        }

        // --- ‰∫§‰∫í‰∏éÁä∂ÊÄÅ ---
        let state = {
            mode: 'TREE', 
            pinching: false, pinchX: 0, pinchY: 0, pinchStabilityCounter: 0,
            lastColorSwitch: 0,
            lastHandX: 0.5, smoothHandX: 0.5, lastHandY: 0.5, smoothHandY: 0.5,
            isSwiping: false, rotVelocityX: 0, rotVelocityY: 0.002
        };

        function switchMode(newMode) {
            if (state.pinching || state.isSwiping) return;
            if (state.mode === newMode) return;
            state.mode = newMode;
            
            instances.forEach(inst => { 
                if (newMode === 'TREE') inst.targetPos = inst.posTree;
                else if (newMode === 'CLOUD') inst.targetPos = inst.posCloud;
                else if (newMode === 'TEXT') inst.targetPos = inst.posText;
            });
            
            photoInstances.forEach(inst => { 
                if (newMode === 'TREE') inst.targetPos = inst.posTree;
                else if (newMode === 'CLOUD') inst.targetPos = inst.posCloud;
                else inst.targetPos = inst.posCloud;
            });

            if (newMode === 'CLOUD') {
                topperState.posCloud.set((Math.random()-0.5)*30, (Math.random()-0.5)*20 + 10, (Math.random()-0.5)*20);
                topperState.targetPos = topperState.posCloud;
            } else if (newMode === 'TEXT') {
                topperState.targetPos = topperState.posText;
            } else {
                topperState.targetPos = topperState.posTree;
            }
        }

        function switchColor() {
            if (state.pinching) return; 
            const now = Date.now();
            if (now - state.lastColorSwitch > 1500) { 
                currentPaletteIndex = (currentPaletteIndex + 1) % PALETTES.length;
                applyColors(currentPaletteIndex);
                state.lastColorSwitch = now;
                topperMat.emissiveIntensity = 3;
                setTimeout(() => topperMat.emissiveIntensity = 1, 200);
            }
        }

        // --- ÊâãÂäøËØÜÂà´ ---
        const videoElement = document.getElementById('webcam_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusText = document.getElementById('gesture-status');

        function detectGesture(landmarks) {
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x-p2.x,2) + Math.pow(p1.y-p2.y,2));
            const isFingerOpen = (tipIdx, pipIdx) => landmarks[tipIdx].y < landmarks[pipIdx].y;
            
            if (dist(thumbTip, indexTip) < 0.05) return "PINCH";
            
            const idxOpen = isFingerOpen(8, 6);
            const midOpen = isFingerOpen(12, 10);
            const ringOpen = isFingerOpen(16, 14);
            const pinkyOpen = isFingerOpen(20, 18);

            if (idxOpen && midOpen && !ringOpen && !pinkyOpen) {
                if (dist(indexTip, middleTip) > 0.05) return "VICTORY";
            }
            if (idxOpen && !midOpen && !ringOpen && !pinkyOpen) return "POINTING"; 
            if (!idxOpen && !midOpen && !ringOpen && !pinkyOpen) return "FIST";
            
            let openCount = 0;
            if (idxOpen) openCount++; if (midOpen) openCount++; if (ringOpen) openCount++; if (pinkyOpen) openCount++;
            if (openCount >= 4) return "OPEN";
            return "NONE";
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.6 });

        hands.onResults(results => {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1});

                state.smoothHandX = THREE.MathUtils.lerp(state.smoothHandX, landmarks[9].x, 0.2);
                state.smoothHandY = THREE.MathUtils.lerp(state.smoothHandY, landmarks[9].y, 0.2);
                
                const deltaX = state.smoothHandX - state.lastHandX;
                const deltaY = state.smoothHandY - state.lastHandY;
                state.lastHandX = state.smoothHandX; state.lastHandY = state.smoothHandY;

                const gesture = detectGesture(landmarks);
                state.pinchX = (landmarks[4].x + landmarks[8].x) - 1; 
                state.pinchY = -((landmarks[4].y + landmarks[8].y) - 1);

                if (state.mode === 'CLOUD' && (Math.abs(deltaX) > 0.03 || Math.abs(deltaY) > 0.03)) { 
                    state.isSwiping = true;
                    state.rotVelocityY += deltaX * 2.5; 
                    state.rotVelocityX += deltaY * 2.5;
                    statusText.innerText = `Gesture: SWIPE (Rotating)`;
                } else {
                    state.isSwiping = false;
                }

                if (gesture === "PINCH") {
                    state.pinchStabilityCounter++;
                    if (state.pinchStabilityCounter > 2) {
                        state.pinching = true;
                        statusText.innerText = "Gesture: PINCH (Locked)";
                    }
                } else {
                    state.pinchStabilityCounter = 0;
                    state.pinching = false;
                    if (!state.isSwiping) statusText.innerText = `Gesture: ${gesture}`;
                }

                if (!state.pinching && !state.isSwiping) {
                    switch(gesture) {
                        case "OPEN": switchMode('CLOUD'); break;
                        case "FIST": switchMode('TREE'); break;
                        case "VICTORY": switchColor(); break;
                        case "POINTING": switchMode('TEXT'); break;
                    }
                }
            } else {
                statusText.innerText = "No Hand";
                state.pinching = false; state.isSwiping = false;
            }
            canvasCtx.restore();
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            document.querySelector('.btn-group').style.display = 'none';
            document.getElementById('cam-container').style.display = 'block';
            playMusic(0);
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 320, height: 240
            });
            cameraUtils.start();
        });

        window.addEventListener('mousedown', () => switchMode('TREE'));
        window.addEventListener('mouseup', () => switchMode('CLOUD'));

        const clock = new THREE.Clock();
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = false; controls.enableDamping = true;
        const tempV = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (state.mode === 'TEXT') {
                state.rotVelocityX = 0; state.rotVelocityY = 0;
                treeGroup.rotation.x = THREE.MathUtils.lerp(treeGroup.rotation.x, 0, 0.1);
                treeGroup.rotation.y = THREE.MathUtils.lerp(treeGroup.rotation.y, 0, 0.1);
                treeGroup.rotation.z = THREE.MathUtils.lerp(treeGroup.rotation.z, 0, 0.1);
            } else {
                state.rotVelocityY = THREE.MathUtils.clamp(state.rotVelocityY, -0.15, 0.15);
                state.rotVelocityX = THREE.MathUtils.clamp(state.rotVelocityX, -0.10, 0.10);
                let baseSpeedY = (state.mode === 'TREE') ? 0.002 : 0.0005; 
                state.rotVelocityY = THREE.MathUtils.lerp(state.rotVelocityY, baseSpeedY, 0.03);
                state.rotVelocityX = THREE.MathUtils.lerp(state.rotVelocityX, 0, 0.05);
                treeGroup.rotation.y += state.rotVelocityY;
                treeGroup.rotation.x += state.rotVelocityX;
                treeGroup.rotation.x = THREE.MathUtils.clamp(treeGroup.rotation.x, -0.5, 0.5);
            }
            photoGroup.rotation.copy(treeGroup.rotation);
            decorGroup.rotation.y = treeGroup.rotation.y; 

            // --- Topper Âä®Áîª ---
            const topperSpeed = (state.mode === 'CLOUD') ? 0.05 : 0.08;
            topperState.currentPos.lerp(topperState.targetPos, topperSpeed);
            if (state.mode !== 'TREE') {
                topperState.currentPos.y += Math.sin(time * 2) * 0.02;
                topperMesh.rotation.y += 0.02;
                topperMesh.rotation.z = Math.sin(time) * 0.1;
            } else {
                topperMesh.rotation.y += 0.01;
                topperMesh.rotation.z = 0;
            }
            topperMesh.position.copy(topperState.currentPos);

            // --- Ë£ÖÈ•∞Âä®Áîª ---
            if(state.mode === 'TREE') {
                spiralMat.opacity = THREE.MathUtils.lerp(spiralMat.opacity, 0.6, 0.05);
                floorRing.material.opacity = THREE.MathUtils.lerp(floorRing.material.opacity, 0.4, 0.05);
                
                // ÊòüÂ∞òÁ≥ªÁªüÊ∑°ÂÖ•
                galaxyMat.opacity = THREE.MathUtils.lerp(galaxyMat.opacity, 0.8, 0.02);
                lineMat.opacity = THREE.MathUtils.lerp(lineMat.opacity, 0.3, 0.02);
            } else {
                spiralMat.opacity = THREE.MathUtils.lerp(spiralMat.opacity, 0, 0.1);
                floorRing.material.opacity = THREE.MathUtils.lerp(floorRing.material.opacity, 0, 0.1);
                
                // ÊòüÂ∞òÁ≥ªÁªüÊ∑°Âá∫
                galaxyMat.opacity = THREE.MathUtils.lerp(galaxyMat.opacity, 0, 0.05);
                lineMat.opacity = THREE.MathUtils.lerp(lineMat.opacity, 0, 0.05);
            }

            // Êõ¥Êñ∞ÊòüÂ∞òÊóãËΩ¨ (Âç≥‰ΩøÁúã‰∏çËßÅ‰πüÂú®ËΩ¨Ôºå‰øùËØÅÂàáÂõûÊù•Êó∂‰∏çÁ™ÅÂÖÄ)
            galaxySystem.rotation.y += 0.001; 
            
            // Êõ¥Êñ∞ÊµÅÊòüÈõ®
            if(lineMat.opacity > 0.01) {
                const positions = shootingLines.geometry.attributes.position.array;
                for(let i=0; i<lineCount; i++) {
                    // Á∫øÊù°Ê≤ø Y ËΩ¥ (ÂûÇÁõ¥) Êàñ Z ËΩ¥ (Á∫µÊ∑±) ÁßªÂä®
                    // ËøôÈáåËÆ©ÂÆÉ‰ª¨ÂÉèÈõ®‰∏ÄÊ†∑ËêΩ‰∏ãÔºåÊàñËÄÖÂÉèÁ©øÊ¢≠‰∏ÄÊ†∑È£ûËøá
                    // Êàë‰ª¨ÈÄâÊã©ÔºöÂêë Z ËΩ¥Ë¥üÊñπÂêëÈ£û (È£ûÂêëÂ±èÂπïÊ∑±Â§Ñ)
                    positions[i*6 + 2] -= lineSpeed[i]; // Head Z
                    positions[i*6 + 5] -= lineSpeed[i]; // Tail Z
                    
                    if(positions[i*6 + 2] < -150) {
                        const newZ = 150;
                        const newX = (Math.random()-0.5) * 300;
                        const newY = (Math.random()-0.5) * 300;
                        positions[i*6] = newX; positions[i*6+1] = newY; positions[i*6+2] = newZ;
                        positions[i*6+3] = newX; positions[i*6+4] = newY - 5; positions[i*6+5] = newZ + 10;
                    }
                }
                shootingLines.geometry.attributes.position.needsUpdate = true;
            }

            if(spiralMat.opacity > 0.01) {
                const spiralPosArr = spiralGeo.attributes.position.array;
                for(let i=0; i<spiralCount; i++) {
                    const ratio = i / spiralCount;
                    const angle = ratio * Math.PI * 8 + time * 0.5; 
                    const radius = 9 - ratio * 8; 
                    const y = ratio * CONFIG.height - CONFIG.height/2;
                    const offset = (i%2===0) ? 0 : Math.PI;
                    spiralPosArr[i*3] = Math.cos(angle + offset) * radius;
                    spiralPosArr[i*3+1] = y;
                    spiralPosArr[i*3+2] = Math.sin(angle + offset) * radius;
                }
                spiralGeo.attributes.position.needsUpdate = true;
                const s = 1 + Math.sin(time * 2) * 0.05;
                floorRing.scale.set(s, s, s);
            }

            // --- Èõ™Ëä±Á≥ªÁªü ---
            if (state.mode === 'TEXT') snowMat.opacity = THREE.MathUtils.lerp(snowMat.opacity, 0.8, 0.02);
            else snowMat.opacity = THREE.MathUtils.lerp(snowMat.opacity, 0, 0.05);

            if (snowMat.opacity > 0.01) {
                const positions = snowGeo.attributes.position.array;
                for(let i=0; i<snowCount; i++) {
                    positions[i*3+1] += snowVel[i].y;
                    positions[i*3] += Math.sin(time + positions[i*3+1]*0.05) * 0.02;
                    if (positions[i*3+1] < -30) {
                        positions[i*3+1] = 30;
                        positions[i*3] = (Math.random()-0.5) * 100;
                        positions[i*3+2] = (Math.random()-0.5) * 50 + 20;
                    }
                }
                snowGeo.attributes.position.needsUpdate = true;
            }

            // --- Á≤íÂ≠êÂä®Áîª ---
            const isCloud = state.mode === 'CLOUD';
            const moveSpeed = isCloud ? CONFIG.floatSpeed : CONFIG.restoreSpeed;

            instances.forEach(inst => {
                inst.currentPos.lerp(inst.targetPos, moveSpeed);
                inst.currentPos.y += Math.sin(time*2 + inst.meshIndex)*0.01;
                
                if(state.mode === 'TEXT') {
                     inst.rotation.x *= 0.9; inst.rotation.y *= 0.9;
                } else if(isCloud) {
                    inst.rotation.x += inst.rotSpeed.x; inst.rotation.y += inst.rotSpeed.y;
                } else {
                    inst.rotation.x += inst.rotSpeed.x * 0.1;
                }
                
                dummy.position.copy(inst.currentPos);
                dummy.rotation.set(inst.rotation.x, inst.rotation.y, inst.rotation.z);
                dummy.scale.setScalar(1);
                dummy.updateMatrix();
                const mesh = inst.type === 'sphere' ? sphereMesh : cubeMesh;
                mesh.setMatrixAt(inst.meshIndex, dummy.matrix);
            });
            sphereMesh.instanceMatrix.needsUpdate = true;
            cubeMesh.instanceMatrix.needsUpdate = true;

            // --- ÁÖßÁâáÂä®Áîª ---
            let closestIdx = -1; let minDist = Infinity; 
            if (state.pinching && state.mode === 'CLOUD' && photoInstances.length > 0) {
                photoInstances.forEach((inst, i) => {
                    inst.mesh.getWorldPosition(tempV);
                    tempV.project(camera); 
                    if (tempV.z < 1) {
                        const dist = Math.sqrt(Math.pow(tempV.x - state.pinchX, 2) + Math.pow(tempV.y - state.pinchY, 2));
                        if (dist < minDist) { minDist = dist; closestIdx = i; }
                    }
                });
            }

            photoInstances.forEach((inst, i) => {
                inst.currentPos.lerp(inst.targetPos, moveSpeed);
                if(isCloud) {
                    inst.currentPos.y += Math.sin(time*1.5 + i)*0.01;
                    inst.mesh.rotation.x += inst.rotVelocity.x; inst.mesh.rotation.y += inst.rotVelocity.y;
                } else {
                    inst.currentPos.y += Math.sin(time*1.5 + i)*0.01;
                    inst.mesh.rotation.x = THREE.MathUtils.lerp(inst.mesh.rotation.x, inst.rotationTree.x, 0.1);
                    inst.mesh.rotation.y = THREE.MathUtils.lerp(inst.mesh.rotation.y, inst.rotationTree.y, 0.1);
                    inst.mesh.rotation.z = THREE.MathUtils.lerp(inst.mesh.rotation.z, inst.rotationTree.z, 0.1);
                }
                inst.mesh.position.copy(inst.currentPos);

                const isSelected = state.pinching && i === closestIdx;
                let targetScale = 0;
                if (state.mode === 'CLOUD') {
                    targetScale = isSelected ? 25.0 : inst.baseScale;
                    inst.mesh.visible = true; 
                } else {
                    targetScale = 0;
                }
                inst.currentScale = THREE.MathUtils.lerp(inst.currentScale, targetScale, 0.1);
                if (state.mode !== 'CLOUD' && inst.currentScale < 0.01) inst.mesh.visible = false;
                inst.mesh.scale.setScalar(inst.currentScale);

                const photoMesh = inst.mesh.children[0];
                const borderMat = inst.mesh.material;
                const photoMat = photoMesh ? photoMesh.material : null;
                
                if (isSelected && state.mode === 'CLOUD') {
                    inst.mesh.lookAt(camera.position); 
                    inst.mesh.renderOrder = 9999;
                    if(photoMesh) photoMesh.renderOrder = 10000;
                    if(borderMat) { borderMat.depthTest = false; borderMat.depthWrite = false; }
                    if(photoMat) { photoMat.depthTest = false; photoMat.depthWrite = false; photoMat.fog = false; photoMat.toneMapped = false; }
                } else {
                    inst.mesh.renderOrder = 0;
                    if(photoMesh) photoMesh.renderOrder = 0;
                    if(borderMat) { borderMat.depthTest = true; borderMat.depthWrite = true; }
                    if(photoMat) { photoMat.depthTest = true; photoMat.depthWrite = true; photoMat.fog = true; photoMat.toneMapped = true; }
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>