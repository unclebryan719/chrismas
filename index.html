<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Galaxy - Hyper Cosmic</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Times New Roman', serif; transition: cursor 0.3s; }
        
        /* éšè—UIæ—¶çš„æ ·å¼ (å…¨å±æ—¶) */
        body.ui-hidden { cursor: none; } 
        body.ui-hidden #ui-container, 
        body.ui-hidden .btn-group, 
        body.ui-hidden #cam-container,
        body.ui-hidden #main-title { /* å¢åŠ æ ‡é¢˜éšè— */
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        /* --- ä¿®æ”¹ï¼šæ ‡é¢˜å±…ä¸­æ ·å¼ --- */
        #main-title {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none; /* å…è®¸ç‚¹å‡»æ ‡é¢˜ä¸‹æ–¹çš„3Då…ƒç´  */
            
            color: #ffeb3b; 
            font-size: 3rem; 
            margin: 0; 
            letter-spacing: 5px;
            text-shadow: 0 0 10px rgba(255,215,0,0.6), 0 0 20px rgba(255,0,0,0.4); 
            text-transform: uppercase;
            transition: opacity 0.5s;
        }

        /* å·¦ä¸Šè§’ UI å®¹å™¨ (ä»…åŒ…å«è¯´æ˜ä¹¦å’ŒéŸ³ä¹çŠ¶æ€) */
        #ui-container {
            position: absolute; top: 20px; left: 20px; width: auto; 
            text-align: left; pointer-events: none; z-index: 10; transition: opacity 0.5s;
        }

        .instructions {
            color: #eee; font-size: 0.95rem; margin-top: 5px; font-family: sans-serif;
            background: rgba(0,0,0,0.6); padding: 20px; border-radius: 15px; display: inline-block;
            border: 1px solid rgba(255,255,255,0.1); line-height: 1.8;
            backdrop-filter: blur(5px);
        }

        .key-point { color: #00ff00; font-weight: bold; text-transform: uppercase; }
        .music-point { color: #00d2ff; font-weight: bold; text-transform: uppercase; border: 1px solid #00d2ff; padding: 2px 6px; border-radius: 4px; }
        .fs-point { color: #ffd700; font-weight: bold; text-transform: uppercase; }
        
        /* æ¡Œé¢ç«¯ä¸“ç”¨å…ƒç´  - é»˜è®¤æ˜¾ç¤ºï¼Œç§»åŠ¨ç«¯éšè— */
        .desktop-only {
            display: inline;
        }
        
        #music-status-display {
            margin-top: 15px; font-family: monospace; font-size: 1.1rem; color: #00d2ff;
            text-shadow: 0 0 5px #00d2ff; display: none !important; /* éšè—éŸ³ä¹çŠ¶æ€æ˜¾ç¤ºï¼Œä»…æ’­æ”¾éŸ³ä¹ */
            background: rgba(0,0,0,0.8); padding: 8px 15px; border-radius: 5px;
            pointer-events: auto; cursor: pointer; border: 1px solid #00d2ff; width: fit-content;
        }
        #music-status-display:hover { background: rgba(0, 210, 255, 0.2); }

        #cam-container {
            position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px;
            border: 2px solid rgba(255,215,0,0.3); border-radius: 10px; overflow: hidden;
            z-index: 20; background: #000; display: none; transition: opacity 0.5s;
        }
        #webcam_video { position: absolute; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.5; }
        #output_canvas { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }
        
        #gesture-status {
            position: absolute; top: 10px; left: 10px; color: #00ff00; font-weight: bold; font-family: monospace; font-size: 16px;
            text-shadow: 0 0 2px black; z-index: 25;
        }

        /* æŒ‰é’®ç»„ï¼šå·¦ä¾§å‚ç›´å±…ä¸­ */
        .btn-group {
            position: absolute; 
            top: 55%; 
            left: 20px; 
            transform: translateY(-50%); 
            
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
            z-index: 30; 
            pointer-events: auto;
            transition: opacity 0.5s;
        }

        .magic-btn {
            width: 220px;
            display: flex;
            justify-content: center;
            align-items: center;

            padding: 15px 0; 
            background: linear-gradient(45deg, #ffd700, #ffaa00);
            border: none; border-radius: 30px; color: #000; font-weight: bold; font-size: 1.1rem;
            cursor: pointer; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); transition: 0.3s;
        }
        .magic-btn:hover { transform: scale(1.05) translateX(10px); background: linear-gradient(45deg, #ffaa00, #ffd700); }
        .magic-btn.secondary { background: linear-gradient(45deg, #00d2ff, #3a7bd5); color: white; }
        
        #file-input-photo { display: none; }
        
        /* å…¨å±æŒ‰é’® - é»˜è®¤éšè—ï¼Œåœ¨ç§»åŠ¨ç«¯æ˜¾ç¤º */
        #fullscreen-btn {
            display: none;
        }
        
        /* æ‰‹æœºå’Œå¹³æ¿æ˜¾ç¤ºå…¨å±æŒ‰é’® */
        @media screen and (max-width: 1024px) {
            #fullscreen-btn {
                display: flex !important;
            }
        }
        
        /* å…¨å±çŠ¶æ€ä¸‹ï¼Œå…¨å±æŒ‰é’®æ˜¾ç¤º"é€€å‡ºå…¨å±" */
        /* å…¨å±æ—¶æŒ‰é’®ä¼šè¢«éšè—ï¼ˆå› ä¸ºUIè¢«éšè—ï¼‰ï¼Œä½†å¯ä»¥é€šè¿‡æ‰‹åŠ¿æˆ–åŒå‡»é€€å‡º */

        /* ========== å“åº”å¼è®¾è®¡ï¼šiPad ========== */
        @media screen and (max-width: 1024px) and (min-width: 768px) {
            #main-title {
                font-size: 2.5rem;
                top: 15px;
                letter-spacing: 3px;
            }

            #ui-container {
                top: 15px;
                left: 15px;
            }

            .instructions {
                font-size: 0.85rem;
                padding: 15px;
                line-height: 1.6;
            }
            
            /* å¹³æ¿ç«¯ä¹Ÿéšè—æ¡Œé¢ç«¯ä¸“ç”¨å…ƒç´  */
            .desktop-only {
                display: none !important;
            }

            #music-status-display {
                font-size: 1rem;
                padding: 6px 12px;
            }

            .btn-group {
                left: 15px;
                gap: 15px;
            }

            .magic-btn {
                width: 180px;
                padding: 12px 0;
                font-size: 1rem;
            }

            #cam-container {
                width: 200px;
                height: 150px;
                bottom: 15px;
                right: 15px;
            }

            #gesture-status {
                font-size: 14px;
            }
        }

        /* ========== å“åº”å¼è®¾è®¡ï¼šæ‰‹æœº ========== */
        @media screen and (max-width: 767px) {
            #main-title {
                font-size: 1.5rem;
                top: 10px;
                letter-spacing: 2px;
            }

            #ui-container {
                top: 10px;
                left: 10px;
                max-width: calc(100% - 20px);
            }

            .instructions {
                font-size: 0.7rem;
                padding: 12px;
                line-height: 1.5;
                max-width: 100%;
            }
            
            /* æ‰‹æœºç«¯éšè—æ¡Œé¢ç«¯ä¸“ç”¨å…ƒç´  */
            .desktop-only {
                display: none !important;
            }

            #music-status-display {
                font-size: 0.85rem;
                padding: 6px 10px;
                margin-top: 10px;
            }

            .btn-group {
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                gap: 12px;
                width: 90%;
                max-width: 280px;
            }

            .magic-btn {
                width: 100%;
                padding: 12px 0;
                font-size: 0.95rem;
            }

            .magic-btn:hover {
                transform: scale(1.05);
            }

            #cam-container {
                width: 160px;
                height: 120px;
                bottom: 10px;
                right: 10px;
            }

            #gesture-status {
                font-size: 12px;
                top: 5px;
                left: 5px;
            }
        }

        /* ========== æ¨ªå±æ‰‹æœºç‰¹æ®Šå¤„ç† ========== */
        @media screen and (max-width: 767px) and (orientation: landscape) {
            #main-title {
                font-size: 1.2rem;
                top: 5px;
            }

            #ui-container {
                top: 5px;
                left: 5px;
            }

            .instructions {
                font-size: 0.65rem;
                padding: 8px;
                line-height: 1.4;
            }

            .btn-group {
                top: auto;
                bottom: 10px;
                left: 10px;
                transform: none;
                flex-direction: row;
                flex-wrap: wrap;
                gap: 8px;
                max-width: calc(100% - 180px);
            }

            .magic-btn {
                width: auto;
                min-width: 120px;
                padding: 8px 15px;
                font-size: 0.85rem;
            }

            #cam-container {
                width: 140px;
                height: 105px;
            }
        }
    </style>

    <!-- NOTE: ä¸ºäº†åœ¨ä¸­å›½æ—  VPN ä¹Ÿèƒ½è¿è¡Œï¼Œè¯·å°†ä»¥ä¸‹ mediapipe ç›¸å…³ js æ–‡ä»¶ä¸‹è½½åˆ°æœ¬åœ°ç›®å½• ./libs/mediapipe/ ä¸‹ -->
    <!-- å¯¹åº”ä¸‹è½½æºï¼ˆä»…ä¾›å‚è€ƒï¼‰ï¼šhttps://cdn.jsdelivr.net/npm/@mediapipe/... -->
    <!-- ä¾‹å¦‚ï¼šcamera_utils.js -> ./libs/mediapipe/camera_utils.js -->
    <script src="./libs/mediapipe/camera_utils.js"></script>
    <script src="./libs/mediapipe/control_utils.js"></script>
    <script src="./libs/mediapipe/drawing_utils.js"></script>
    <script src="./libs/mediapipe/hands.js"></script>
</head>
<body>

    <!-- ä¿®æ”¹ï¼šæ ‡é¢˜å•ç‹¬æ”¾ç½®ï¼Œå®ç°å±å¹•å±…ä¸­ -->
    <h1 id="main-title">Christmas Galaxy</h1>

    <div id="ui-container">
        <!-- æ ‡é¢˜å·²ç§»å‡ºï¼Œæ­¤å¤„ä¿ç•™è¯´æ˜ä¹¦ -->
        <div class="instructions">
            ğŸ‘‹ <span class="key-point">Swipe</span>: è½¬åŠ¨<br>
            ğŸ–ï¸ <span class="key-point">Open</span>: çˆ†ç‚¸<br>
            âœŠ <span class="key-point">Fist</span>: åœ£è¯æ ‘<br>
            â˜ï¸ <span class="key-point">Point</span>: æ–‡å­—æ¨¡å¼</b><br>
            ğŸ¤ <span class="key-point">Pinch</span>: å›¾ç‰‡æ”¾å¤§<br>
            âœŒï¸ <span class="key-point">Victory</span>: æ¢é¢œè‰²<br>
            <br>
            <span class="desktop-only"><span class="fs-point">F</span>: å…¨å±ï¼ˆæ¡Œé¢ç«¯ï¼‰</span>
        </div>
        <div id="music-status-display" title="Click to Toggle">ğŸµ Music: Waiting...</div>
    </div>

    <!-- æŒ‰é’®ç»„ï¼šä½äºå±å¹•å·¦ä¾§ -->
    <div class="btn-group">
        <label for="file-input-photo" class="magic-btn secondary">ğŸ“‚ é€‰æ‹©ç…§ç‰‡</label>
        <!-- ç§»åŠ¨ç«¯ï¼šä½¿ç”¨æ ‡å‡†å›¾ç‰‡é€‰æ‹©ï¼Œä¸ä½¿ç”¨æ–‡ä»¶å¤¹é€‰æ‹© -->
        <input type="file" id="file-input-photo" multiple accept="image/*">

        <button id="start-btn" class="magic-btn">ğŸ“¸ å¼€å§‹</button>
        
        <!-- ç§»åŠ¨ç«¯å…¨å±æŒ‰é’® -->
        <button id="fullscreen-btn" class="magic-btn secondary" style="display: none;">ğŸ–¥ï¸ å…¨å±</button>
    </div>

    <div id="cam-container">
        <!-- æ³¨æ„ï¼šplaysinline / muted / autoplay å¯¹ iOS å¿…é¡» -->
        <video id="webcam_video" playsinline autoplay muted></video>
        <canvas id="output_canvas"></canvas>
        <div id="gesture-status">System Ready</div>
    </div>

    <audio id="bg-music" preload="auto"></audio>

    <!-- three.js æ”¹ä¸ºæœ¬åœ°æ¨¡å—ï¼š
         è¯·ä¸‹è½½ three@0.160.0 çš„æ„å»ºæ–‡ä»¶åˆ° ./libs/three/ ç›®å½•ï¼Œä¾‹å¦‚ï¼š
         - ./libs/three/build/three.module.js
         - ./libs/three/examples/jsm/*
         ç„¶åä½¿ç”¨ä¸‹é¢çš„æœ¬åœ° importmapã€‚ -->
    <script type="importmap">
        {
            "imports": {
                "three": "./libs/three/build/three.module.js",
                "three/addons/": "./libs/three/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

        // --- 0. éŸ³ä¹ç³»ç»Ÿ ---
        const PLAYLIST = [
            { title: "We Wish You a Merry Christmas", src: "music/we_wish_you_a_merry_christmas.mp3" },
            { title: "Jingle Bells", src: "music/jingle_bells.mp3" },
            { title: "Deck the Halls", src: "music/deck_the_halls.mp3" },
            { title: "Silent Night", src: "music/silent_night.mp3" }
        ];
        
        let currentSongIndex = 0;
        const audioEl = document.getElementById('bg-music');
        const musicDisplay = document.getElementById('music-status-display');

        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyF') toggleFullscreen();
        });
        
        // ç§»åŠ¨ç«¯å…¨å±æŒ‰é’®äº‹ä»¶
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            toggleFullscreen();
        });

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                // è¿›å…¥å…¨å±
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().catch(e => console.log(e));
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) {
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            } else {
                // é€€å‡ºå…¨å±
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        function updateFullscreenButton() {
            const btn = document.getElementById('fullscreen-btn');
            if (document.fullscreenElement || 
                document.webkitFullscreenElement || 
                document.mozFullScreenElement || 
                document.msFullscreenElement) {
                btn.textContent = 'ğŸ“± é€€å‡ºå…¨å±';
            } else {
                btn.textContent = 'ğŸ–¥ï¸ å…¨å±';
            }
        }

        document.addEventListener('fullscreenchange', () => {
            document.body.classList.toggle('ui-hidden', !!document.fullscreenElement);
            updateFullscreenButton();
        });
        
        document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
        document.addEventListener('mozfullscreenchange', updateFullscreenButton);
        document.addEventListener('MSFullscreenChange', updateFullscreenButton);

        musicDisplay.addEventListener('click', () => {
            if (audioEl.paused) {
                if (audioEl.src) audioEl.play().catch(e => console.warn(e));
                else playMusic(currentSongIndex);
            } else nextSong();
        });

        audioEl.addEventListener('error', () => {
            musicDisplay.innerText = "âŒ Network Error (Skip in 2s)";
            musicDisplay.style.color = 'orange';
            setTimeout(() => nextSong(), 2000);
        });

        audioEl.addEventListener('ended', nextSong);

        function playMusic(index) {
            currentSongIndex = (index + PLAYLIST.length) % PLAYLIST.length;
            const song = PLAYLIST[currentSongIndex];
            musicDisplay.style.display = 'block';
            musicDisplay.innerText = `âŒ› Buffering: ${song.title}...`;
            musicDisplay.style.color = '#00d2ff';
            audioEl.src = song.src;
            audioEl.volume = 1.0; 
            audioEl.play().then(() => {
                musicDisplay.innerText = `ğŸµ Playing: ${song.title}`;
                musicDisplay.style.color = '#00ff00';
            }).catch(() => {
                musicDisplay.innerText = `âš ï¸ Click Here to Enable Audio`;
                musicDisplay.style.color = 'yellow';
            });
        }
        function nextSong() { playMusic(currentSongIndex + 1); }

        // --- 1. åœºæ™¯é…ç½® ---
        const CONFIG = {
            count: 6000,
            radius: 8,       
            height: 25,      
            restoreSpeed: 0.08,
            floatSpeed: 0.05
        };

        const PALETTES = [
            { name: "Classic Gold/Red", gold: 0xFFD700, red: 0xD41E3A, green: 0x005235 }, 
            { name: "Frozen Silver/Blue", gold: 0xE0FFFF, red: 0x4682B4, green: 0x708090 }, 
            { name: "Candy Pop", gold: 0xFF69B4, red: 0x00FFFF, green: 0x9370DB } 
        ];
        let currentPaletteIndex = 0;
        let currentBorderColor = new THREE.Color(PALETTES[0].gold); 

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.010);

        // æ£€æµ‹è®¾å¤‡ç±»å‹å’Œå±å¹•å°ºå¯¸
        const isMobile = window.innerWidth <= 767;
        const isTablet = window.innerWidth > 767 && window.innerWidth <= 1024;
        const isLandscape = window.innerWidth > window.innerHeight;

        // æ ¹æ®è®¾å¤‡è°ƒæ•´ç›¸æœºå‚æ•°
        let cameraFOV = 45;
        let cameraZ = 55;
        let cameraY = 5;
        
        if (isMobile) {
            if (isLandscape) {
                cameraFOV = 60;
                cameraZ = 45;
                cameraY = 3;
            } else {
                cameraFOV = 55;
                cameraZ = 50;
                cameraY = 4;
            }
        } else if (isTablet) {
            cameraFOV = 50;
            cameraZ = 52;
            cameraY = 4.5;
        }

        const camera = new THREE.PerspectiveCamera(cameraFOV, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, cameraY, cameraZ);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        document.body.appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const mainLight = new THREE.DirectionalLight(0xffeeb1, 2.0);
        mainLight.position.set(0, 50, 20);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);
        camera.add(new THREE.PointLight(0xffffff, 0.8));
        scene.add(camera);

        // --- è£…é¥° (Decorations) ---
        const decorGroup = new THREE.Group();
        scene.add(decorGroup);

        const spiralGeo = new THREE.BufferGeometry();
        const spiralCount = 600;
        const spiralPos = new Float32Array(spiralCount * 3);
        for(let i=0; i<spiralCount; i++) {
            spiralPos[i*3] = 0; spiralPos[i*3+1] = 0; spiralPos[i*3+2] = 0; 
        }
        spiralGeo.setAttribute('position', new THREE.BufferAttribute(spiralPos, 3));
        const spiralMat = new THREE.PointsMaterial({ 
            color: 0xffaa00, size: 0.4, transparent: true, opacity: 0.6, 
            blending: THREE.AdditiveBlending 
        });
        const spiralSystem = new THREE.Points(spiralGeo, spiralMat);
        decorGroup.add(spiralSystem);

        const ringGeo = new THREE.RingGeometry(8, 9, 64);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xffd700, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
        const floorRing = new THREE.Mesh(ringGeo, ringMat);
        floorRing.rotation.x = -Math.PI / 2;
        floorRing.position.y = -CONFIG.height / 2 - 2;
        decorGroup.add(floorRing);


        // --- 2. ç²’å­ä¸å¯¹è±¡ ---
        const sphereMaterial = new THREE.MeshStandardMaterial({ metalness: 0.8, roughness: 0.2 });
        const cubeMaterial = new THREE.MeshStandardMaterial({ metalness: 0.7, roughness: 0.4 });
        const sphereMesh = new THREE.InstancedMesh(new THREE.SphereGeometry(0.35, 12, 12), sphereMaterial, CONFIG.count);
        const cubeMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), cubeMaterial, CONFIG.count);
        sphereMesh.castShadow = true; sphereMesh.receiveShadow = true;
        cubeMesh.castShadow = true; cubeMesh.receiveShadow = true;
        
        const treeGroup = new THREE.Group();
        treeGroup.add(sphereMesh);
        treeGroup.add(cubeMesh);
        scene.add(treeGroup);

        const topperMat = new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xffaa00, emissiveIntensity: 1 });
        const topperMesh = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), topperMat);
        treeGroup.add(topperMesh);

        // æ˜Ÿçš„è¿åŠ¨çŠ¶æ€
        // posText å°†åœ¨åˆ‡æ¢åˆ°æ–‡å­—æ¨¡å¼æ—¶æ ¹æ®æ–‡å­—é…ç½®åŠ¨æ€è®¡ç®—
        const topperState = {
            posTree: new THREE.Vector3(0, CONFIG.height/2+1.5, 0), 
            posCloud: new THREE.Vector3(0, 20, 0), 
            posText: new THREE.Vector3(0, 8, 0),   // åˆå§‹å€¼ï¼Œå°†åœ¨æ–‡å­—æ¨¡å¼ä¸‹åŠ¨æ€æ›´æ–°
            currentPos: new THREE.Vector3(0, CONFIG.height/2+1.5, 0),
            targetPos: new THREE.Vector3(0, CONFIG.height/2+1.5, 0),
            floatOffset: 0
        };

        const instances = [];
        const photoInstances = [];
        const dummy = new THREE.Object3D();
        const _color = new THREE.Color();

        function getTreePos(i, total) {
            const ratio = i / total;
            const y = ratio * CONFIG.height - CONFIG.height/2;
            const r = Math.pow((1-ratio), 0.9) * CONFIG.radius;
            const angle = i * 137.5;
            const rad = Math.sqrt(Math.random()) * r;
            return new THREE.Vector3(Math.cos(angle)*rad, y, Math.sin(angle)*rad);
        }

        function getCloudPos() {
            return new THREE.Vector3(
                (Math.random() - 0.5) * 180, 
                (Math.random() - 0.5) * 100, 
                (Math.random() - 0.5) * 100 
            );
        }

        function getSafeZonePos() {
            return new THREE.Vector3(
                (Math.random() - 0.5) * 50, 
                (Math.random() - 0.5) * 30, 
                (Math.random() - 0.5) * 20  
            );
        }

        // ====================================================
        // --- NEW: è¶…æ—¶ç©ºæ˜Ÿå°˜é£æš´ (Hyper Cosmic Storm) ---
        // ====================================================
        
        // 1. ç”ŸæˆæŸ”å’Œå…‰ç‚¹æè´¨
        const glowCanvas = document.createElement('canvas');
        glowCanvas.width = 32; glowCanvas.height = 32;
        const ctx = glowCanvas.getContext('2d');
        const grd = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grd.addColorStop(0, 'rgba(255, 255, 255, 1)');
        grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grd; ctx.fillRect(0, 0, 32, 32);
        const glowTex = new THREE.CanvasTexture(glowCanvas);

        // 2. æ˜Ÿå°˜ç³»ç»Ÿ (å…¨å±è¦†ç›–)
        const galaxyGeo = new THREE.BufferGeometry();
        const galaxyCount = 3000;
        const galaxyPos = new Float32Array(galaxyCount * 3);
        const galaxySizes = new Float32Array(galaxyCount);
        
        for(let i=0; i<galaxyCount; i++) {
            // åœ¨å·¨å¤§çš„çƒä½“å†…éšæœºåˆ†å¸ƒ (Radius 150)
            // æ‘„åƒæœºåœ¨ Z=55ï¼Œæ‰€ä»¥èŒƒå›´è¦æ¶µç›–å¹¶è¶…è¶Šæ‘„åƒæœº
            const r = Math.random() * 150; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            galaxyPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
            galaxyPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            galaxyPos[i*3+2] = r * Math.cos(phi);
            
            // éšæœºå¤§å°ï¼Œåˆ¶é€ æ™¯æ·±æ„Ÿ
            galaxySizes[i] = Math.random() * 1.5 + 0.5;
        }
        galaxyGeo.setAttribute('position', new THREE.BufferAttribute(galaxyPos, 3));
        galaxyGeo.setAttribute('size', new THREE.BufferAttribute(galaxySizes, 1));
        
        const galaxyMat = new THREE.PointsMaterial({
            color: 0xffcc00, 
            size: 1.0, 
            map: glowTex,
            transparent: true, opacity: 0, 
            depthWrite: false, 
            blending: THREE.AdditiveBlending
        });
        const galaxySystem = new THREE.Points(galaxyGeo, galaxyMat);
        scene.add(galaxySystem);

        // 3. æµæ˜Ÿé›¨ (Shooting Lines) - å¢åŠ é€Ÿåº¦æ„Ÿ
        const lineGeo = new THREE.BufferGeometry();
        const lineCount = 150;
        const linePos = [];
        const lineSpeed = [];
        
        for(let i=0; i<lineCount; i++) {
            // éšæœºèµ·ç‚¹
            const x = (Math.random()-0.5) * 300;
            const y = (Math.random()-0.5) * 300;
            const z = (Math.random()-0.5) * 300;
            // æ¯æ¡çº¿ä¸¤ä¸ªç‚¹
            linePos.push(x, y, z);
            linePos.push(x, y - 5, z); // å°¾å·´é•¿åº¦
            lineSpeed.push((Math.random() + 0.5) * 2); // é€Ÿåº¦
        }
        lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
        const lineMat = new THREE.LineBasicMaterial({
            color: 0xffffff, transparent: true, opacity: 0, blending: THREE.AdditiveBlending
        });
        const shootingLines = new THREE.LineSegments(lineGeo, lineMat);
        scene.add(shootingLines);


        // --- 4. é›ªèŠ±ç³»ç»Ÿ ---
        const snowGeo = new THREE.BufferGeometry();
        const snowCount = 1500;
        const snowPos = new Float32Array(snowCount * 3);
        const snowVel = []; 
        for(let i=0; i<snowCount; i++) {
            snowPos[i*3] = (Math.random()-0.5) * 100;
            snowPos[i*3+1] = (Math.random()-0.5) * 60;
            snowPos[i*3+2] = (Math.random()-0.5) * 50 + 20;
            snowVel.push({
                x: (Math.random()-0.5)*0.05,
                y: -(Math.random()*0.1 + 0.05),
                z: (Math.random()-0.5)*0.05
            });
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        // å°†é›ªèŠ±çº¹ç†æ¢æˆæœ¬åœ°æ–‡ä»¶ï¼šè¯·ä¸‹è½½ snowflake1.png æ”¾åˆ° ./assets/textures/ ä¸‹
        // åŸåœ°å€ï¼ˆä»…ä¾›å‚è€ƒï¼‰ï¼šhttps://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/snowflake1.png
        // ä½¿ç”¨æœ¬åœ°ç”Ÿæˆçš„é›ªèŠ±çº¹ç†ï¼Œé¿å…ä¾èµ–å¤–éƒ¨æ–‡ä»¶ç¼ºå¤±å¯¼è‡´ä¸å¯è§
        function createSnowTexture() {
            const c = document.createElement('canvas');
            c.width = c.height = 64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 24);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.4, 'rgba(255,255,255,0.8)');
            g.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 64, 64);
            const tex = new THREE.CanvasTexture(c);
            tex.anisotropy = 4;
            tex.needsUpdate = true;
            return tex;
        }
        const snowTexture = createSnowTexture();
        const snowMat = new THREE.PointsMaterial({
            color: 0xffffff, size: 0.8, map: snowTexture, 
            transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending
        });
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);

        // --- 4b. æ–‡å­—æ¨¡å¼ä¸“å±é£˜é›ªï¼ˆæ›´å¤§ã€æ›´è¿‘ï¼Œåˆ‡æ¢ TEXT æ—¶æ·¡å…¥ï¼‰ ---
        const textSnowGeo = new THREE.BufferGeometry();
        const textSnowCount = 1200; // æ›´å¯†é›†çš„å‰æ™¯é›ª
        const textSnowPos = new Float32Array(textSnowCount * 3);
        const textSnowVel = [];
        for (let i = 0; i < textSnowCount; i++) {
            textSnowPos[i*3]   = (Math.random()-0.5) * 80;   // æ›´é è¿‘é•œå¤´èŒƒå›´
            textSnowPos[i*3+1] = 20 + Math.random() * 50;    // ä¸Šæ–¹å‡ºç°
            textSnowPos[i*3+2] = (Math.random()-0.5) * 45;   // ä¸­æ™¯
            textSnowVel.push({
                x: (Math.random()-0.5) * 0.08,
                y: -(Math.random()*0.25 + 0.06),
                z: (Math.random()-0.5) * 0.06
            });
        }
        textSnowGeo.setAttribute('position', new THREE.BufferAttribute(textSnowPos, 3));
        const textSnowMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 2.0,
            map: snowTexture,
            transparent: true,
            opacity: 0,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        const textSnowSystem = new THREE.Points(textSnowGeo, textSnowMat);
        scene.add(textSnowSystem);

        // --- 5. æ–‡å­—ç”Ÿæˆé€»è¾‘ ---
        let textPoints = [];
        const fontLoader = new FontLoader();
        
        // æ ¹æ®å±å¹•å®½åº¦è‡ªåŠ¨é€‚é…æ–‡å­—å¤§å°å’Œä½ç½®
        function getTextConfig() {
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            
            // ç¡®å®šè¾¹è·è¦æ±‚ï¼ˆåƒç´ å€¼ï¼Œç”¨äºè®¡ç®—å¯ç”¨å®½åº¦ï¼‰
            // æ‰‹æœºç«¯ï¼šè®¾ç½®åˆç†çš„è¾¹è·ï¼ˆ10-15pxï¼‰ï¼Œé€šè¿‡è°ƒæ•´ç›¸æœºè·ç¦»æ¥å®ç°ï¼Œè€Œä¸æ˜¯ç¼©å°æ–‡å­—
            const isMobile = screenWidth <= 767;
            const marginPx = isMobile ? 12 : (screenWidth <= 1024 ? 20 : 40); // æ‰‹æœº12pxï¼Œå¹³æ¿20pxï¼Œç”µè„‘40px
            
            // æ ¹æ®å±å¹•å®½åº¦ç›´æ¥è®¡ç®—å­—æ¯å¤§å°
            // æ‰‹æœºç«¯ï¼šå°½å¯èƒ½è®©å­—æ¯å¤§ä¸€äº›ï¼Œé€šè¿‡è°ƒæ•´ç›¸æœºè·ç¦»æ¥ç¡®ä¿è¾¹è·
            let size;
            if (screenWidth <= 375) {
                // å°å±æ‰‹æœºï¼ˆiPhone SEç­‰ï¼‰- å¢å¤§æ–‡å­—
                size = 1.4 + (screenWidth - 320) / 55 * 0.4; // 320-375px: 1.4-1.8
            } else if (screenWidth <= 480) {
                // æ ‡å‡†æ‰‹æœº - å¢å¤§æ–‡å­—
                size = 1.8 + (screenWidth - 375) / 105 * 0.5; // 375-480px: 1.8-2.3
            } else if (screenWidth <= 768) {
                // å¤§å±æ‰‹æœº/å°å¹³æ¿
                size = 2.3 + (screenWidth - 480) / 288 * 0.5; // 480-768px: 2.3-2.8
            } else if (screenWidth <= 1024) {
                // å¹³æ¿
                size = 2.5 + (screenWidth - 768) / 256 * 0.5; // 768-1024px: 2.5-3.0
            } else if (screenWidth <= 1920) {
                // å°å±ç”µè„‘
                size = 3.0 + (screenWidth - 1024) / 896 * 0.8; // 1024-1920px: 3.0-3.8
            } else {
                // å¤§å±ç”µè„‘
                size = 3.8 + Math.min((screenWidth - 1920) / 1920 * 0.7, 0.7); // 1920px+: 3.8-4.5
            }
            
            // é™åˆ¶å¤§å°èŒƒå›´
            size = Math.max(1.0, Math.min(4.5, size));
            
            // ä¸å†ç¼©å°æ–‡å­—ï¼Œè¾¹è·é€šè¿‡è°ƒæ•´ç›¸æœºè·ç¦»æ¥å®ç°
            // è¿™æ ·å¯ä»¥è®©å­—æ¯å°½å¯èƒ½å¤§ï¼ŒåŒæ—¶ä¿æŒè¾¹è·
            
            // æ ¹æ®å±å¹•å®½åº¦åŠ¨æ€è®¡ç®—å­—æ¯é—´è·
            // æ‰‹æœºç«¯ï¼šä¿æŒæ¸…æ™°çš„å­—æ¯é—´è·
            let letterSpacing;
            if (screenWidth <= 480) {
                // æ‰‹æœºç«¯ï¼šç¨å¾®å¢åŠ å­—æ¯é—´è·ï¼Œç¡®ä¿æ¸…æ™°
                letterSpacing = 0.06 + (screenWidth - 320) / 160 * 0.04; // 0.06-0.10
            } else if (screenWidth <= 768) {
                letterSpacing = 0.10 + (screenWidth - 480) / 288 * 0.02; // 0.10-0.12
            } else if (screenWidth <= 1024) {
                letterSpacing = 0.10 + (screenWidth - 768) / 256 * 0.02; // 0.10-0.12
            } else {
                letterSpacing = 0.12 + Math.min((screenWidth - 1024) / 1920 * 0.03, 0.03); // 0.12-0.15
            }
            letterSpacing = Math.max(0.05, Math.min(0.18, letterSpacing));
            
            // æ ¹æ®å­—æ¯å¤§å°å’Œå±å¹•é«˜åº¦è®¡ç®—å‚ç›´ä½ç½®
            const y1 = size * 0.7;  // "MERRY" ä½ç½®ï¼ˆä½¿ç”¨ç›¸åŒçš„sizeï¼‰
            const y2 = -size * 0.7; // "CHRISTMAS" ä½ç½®
            
            // æ ¹æ®å­—æ¯å¤§å°è®¡ç®—åšåº¦
            const spacing = size * 0.04;
            
            return { 
                size: size,  // Merryå’ŒChristmasä½¿ç”¨ç›¸åŒçš„å¤§å°
                y1: y1, 
                y2: y2, 
                spacing: spacing, 
                letterSpacing: letterSpacing  // Merryå’ŒChristmasä½¿ç”¨ç›¸åŒçš„é—´è·
            };
        }
        
        // ç²¾ç¡®çš„å­—æ¯é—´è·å‡½æ•°ï¼šåˆ†åˆ«åˆ›å»ºæ¯ä¸ªå­—æ¯å¹¶æ‰‹åŠ¨è°ƒæ•´ä½ç½®ï¼Œæ”¯æŒç²¾ç»†å¾®è°ƒ
        function createTextWithLetterSpacing(font, text, size, height, letterSpacing) {
            const letters = text.split('');
            const letterGeometries = [];
            let currentX = 0;
            
            // ä¸ºæ¯ä¸ªå­—æ¯åˆ›å»ºå‡ ä½•ä½“å¹¶è®¡ç®—ä½ç½®
            letters.forEach((letter) => {
                const letterGeo = new TextGeometry(letter, {
                    font: font,
                    size: size,
                    height: height,
                    curveSegments: 6,
                    bevelEnabled: false
                });
                
                // è®¡ç®—å­—æ¯çš„è¾¹ç•Œæ¡†
                letterGeo.computeBoundingBox();
                const box = letterGeo.boundingBox;
                const letterWidth = box.max.x - box.min.x;
                
                // å°†å­—æ¯å‡ ä½•ä½“ç§»åŠ¨åˆ°æ­£ç¡®ä½ç½®
                const offsetX = currentX - box.min.x;
                letterGeo.translate(offsetX, 0, 0);
                
                letterGeometries.push(letterGeo);
                
                // æ›´æ–°ä¸‹ä¸€ä¸ªå­—æ¯çš„èµ·å§‹ä½ç½®ï¼ˆå­—æ¯å®½åº¦ + é—´è·ï¼‰
                // letterSpacing å€¼ä¹˜ä»¥ size * 2ï¼Œè®©é—´è·å˜åŒ–æ›´æ˜æ˜¾ï¼Œæ”¯æŒç²¾ç»†è°ƒæ•´
                // ä¾‹å¦‚ï¼šletterSpacing=0.05 æ—¶ï¼Œå®é™…é—´è· = 0.05 * size * 2
                currentX += letterWidth + (letterSpacing * size * 2);
            });
            
            // åˆå¹¶æ‰€æœ‰å­—æ¯çš„å‡ ä½•ä½“
            const mergedGeo = new THREE.BufferGeometry();
            const mergedPositions = [];
            const mergedNormals = [];
            const mergedUvs = [];
            const mergedIndices = [];
            let vertexOffset = 0;
            
            letterGeometries.forEach((geo) => {
                const pos = geo.attributes.position;
                const normal = geo.attributes.normal;
                const uv = geo.attributes.uv;
                const index = geo.index;
                
                // æ·»åŠ é¡¶ç‚¹
                for (let i = 0; i < pos.count; i++) {
                    mergedPositions.push(pos.getX(i), pos.getY(i), pos.getZ(i));
                    if (normal) {
                        mergedNormals.push(normal.getX(i), normal.getY(i), normal.getZ(i));
                    }
                    if (uv) {
                        mergedUvs.push(uv.getX(i), uv.getY(i));
                    }
                }
                
                // æ·»åŠ ç´¢å¼•
                if (index) {
                    for (let i = 0; i < index.count; i++) {
                        mergedIndices.push(index.getX(i) + vertexOffset);
                    }
                }
                
                vertexOffset += pos.count;
            });
            
            mergedGeo.setAttribute('position', new THREE.Float32BufferAttribute(mergedPositions, 3));
            if (mergedNormals.length > 0) {
                mergedGeo.setAttribute('normal', new THREE.Float32BufferAttribute(mergedNormals, 3));
            }
            if (mergedUvs.length > 0) {
                mergedGeo.setAttribute('uv', new THREE.Float32BufferAttribute(mergedUvs, 2));
            }
            if (mergedIndices.length > 0) {
                mergedGeo.setIndex(mergedIndices);
            }
            
            // å±…ä¸­æ•´ä¸ªæ–‡å­—
            mergedGeo.computeBoundingBox();
            const mergedBox = mergedGeo.boundingBox;
            const centerX = (mergedBox.min.x + mergedBox.max.x) / 2;
            mergedGeo.translate(-centerX, 0, 0);
            
            // æ¸…ç†ä¸´æ—¶å‡ ä½•ä½“
            letterGeometries.forEach(geo => geo.dispose());
            
            return mergedGeo;
        }
        
        const textConfig = getTextConfig();
        
        // å­—ä½“ä¹Ÿä½¿ç”¨æœ¬åœ°æ–‡ä»¶ï¼šè¯·å°† helvetiker_bold.typeface.json æ”¾åˆ° ./assets/fonts/ ä¸‹
        // åŸåœ°å€ï¼ˆä»…ä¾›å‚è€ƒï¼‰ï¼šhttps://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json
        fontLoader.load('./assets/fonts/helvetiker_bold.typeface.json', (font) => {
            
            // ä½¿ç”¨ç²¾ç¡®çš„å­—æ¯é—´è·å‡½æ•°åˆ›å»ºæ–‡å­—
            const geo1 = createTextWithLetterSpacing(
                font, 
                'MERRY', 
                textConfig.size, 
                textConfig.spacing, 
                textConfig.letterSpacing
            );
            const mesh1 = new THREE.Mesh(geo1, new THREE.MeshBasicMaterial());
            mesh1.position.y = textConfig.y1; 
            mesh1.updateMatrixWorld();

            // ä½¿ç”¨ç²¾ç¡®çš„å­—æ¯é—´è·å‡½æ•°åˆ›å»ºæ–‡å­—
            const geo2 = createTextWithLetterSpacing(
                font, 
                'CHRISTMAS', 
                textConfig.size, 
                textConfig.spacing, 
                textConfig.letterSpacing
            );
            const mesh2 = new THREE.Mesh(geo2, new THREE.MeshBasicMaterial());
            mesh2.position.y = textConfig.y2; 
            mesh2.updateMatrixWorld();

            const sampler1 = new MeshSurfaceSampler(mesh1).build();
            const sampler2 = new MeshSurfaceSampler(mesh2).build();
            
            textPoints = [];
            const tempPos = new THREE.Vector3();
            const tempTarget = new THREE.Vector3();

            const halfCount = Math.floor(CONFIG.count / 2);
            for (let i = 0; i < CONFIG.count; i++) {
                if (i < halfCount) {
                    sampler1.sample(tempPos);
                    tempTarget.copy(tempPos).applyMatrix4(mesh1.matrixWorld);
                } else {
                    sampler2.sample(tempPos);
                    tempTarget.copy(tempPos).applyMatrix4(mesh2.matrixWorld);
                }
                textPoints.push(new THREE.Vector3(tempTarget.x, tempTarget.y, 0));
            }
            
            instances.forEach((inst, i) => {
                if (textPoints[i]) inst.posText = textPoints[i];
                else inst.posText = inst.posTree; 
            });
            console.log("Text Geometry Loaded");
        });

        // --- åˆå§‹åŒ–ç²’å­ ---
        let sIdx=0, cIdx=0;
        for(let i=0; i<CONFIG.count; i++) {
            const isSphere = Math.random()>0.5;
            const mesh = isSphere ? sphereMesh : cubeMesh;
            const idx = isSphere ? sIdx++ : cIdx++;
            
            const treePos = getTreePos(i, CONFIG.count);
            const cloudPos = getCloudPos(); 
            
            instances.push({
                type: isSphere ? 'sphere' : 'cube',
                meshIndex: idx,
                targetPos: treePos, 
                posTree: treePos,  
                posCloud: cloudPos,
                posText: cloudPos, 
                currentPos: treePos.clone(),
                rotSpeed: {x:(Math.random()-0.5)*0.05, y:(Math.random()-0.5)*0.05},
                rotation: new THREE.Euler(Math.random()*6, Math.random()*6, 0)
            });
            
            dummy.position.copy(treePos);
            dummy.scale.setScalar(0.5 + Math.random());
            dummy.updateMatrix();
            mesh.setMatrixAt(idx, dummy.matrix);
        }

        function applyColors(paletteIdx) {
            const p = PALETTES[paletteIdx];
            currentBorderColor.setHex(p.gold); 
            topperMat.color.setHex(p.gold);
            topperMat.emissive.setHex(p.red); 
            
            spiralMat.color.setHex(p.gold);
            floorRing.material.color.setHex(p.gold);
            
            // æ˜Ÿå°˜é¢œè‰²è”åŠ¨
            galaxyMat.color.setHex(p.gold);
            lineMat.color.setHex(p.gold);

            photoInstances.forEach(inst => {
                if(inst.mesh.material) inst.mesh.material.color.setHex(p.gold); 
            });

            for(let i=0; i<CONFIG.count; i++) {
                const isSphere = instances[i].type === 'sphere';
                if(isSphere) _color.setHex(Math.random()>0.3 ? p.gold : p.red);
                else _color.setHex(Math.random()>0.5 ? p.gold : p.green);
                const mesh = isSphere ? sphereMesh : cubeMesh;
                mesh.setColorAt(instances[i].meshIndex, _color);
            }
            sphereMesh.instanceColor.needsUpdate = true;
            cubeMesh.instanceColor.needsUpdate = true;
        }
        applyColors(0);

        // --- ç…§ç‰‡å¤„ç† ---
        const photoGroup = new THREE.Group();
        scene.add(photoGroup);
        document.getElementById('file-input-photo').addEventListener('change', handleFileSelect);

        function handleFileSelect(event) {
            const files = Array.from(event.target.files).filter(f => f.type.startsWith('image/'));
            if(files.length === 0) return;
            photoInstances.forEach(p => {
                photoGroup.remove(p.mesh);
                p.mesh.geometry.dispose(); p.mesh.material.dispose();
                if (p.mesh.children[0]) { p.mesh.children[0].geometry.dispose(); p.mesh.children[0].material.dispose(); }
            });
            photoInstances.length = 0;

            const loader = new THREE.TextureLoader();
            const photoCount = Math.min(files.length, 60); 
            
            files.slice(0, photoCount).forEach((file, i) => {
                loader.load(URL.createObjectURL(file), (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    const aspect = texture.image.width / texture.image.height;
                    const photoW = 0.8; const photoH = photoW / aspect;
                    
                    const borderMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(photoW+0.06, photoH+0.06, 0.04),
                        new THREE.MeshStandardMaterial({ color: currentBorderColor, roughness: 0.2, metalness: 0.8 })
                    );
                    const photoMesh = new THREE.Mesh(
                        new THREE.PlaneGeometry(photoW, photoH),
                        new THREE.MeshBasicMaterial({ map: texture })
                    );
                    photoMesh.position.z = 0.022;
                    borderMesh.add(photoMesh);

                    const treePos = getTreePos(i, photoCount);
                    treePos.x *= 1.05; treePos.z *= 1.05;

                    const cloudPos = getSafeZonePos(); 
                    
                    borderMesh.position.copy(treePos);
                    borderMesh.lookAt(0, treePos.y, 0); 
                    photoGroup.add(borderMesh);
                    
                    photoInstances.push({
                        mesh: borderMesh,
                        posTree: treePos, 
                        posCloud: cloudPos, 
                        targetPos: treePos, currentPos: treePos.clone(),
                        baseScale: 1.0, currentScale: 1.0,
                        rotationTree: borderMesh.rotation.clone(),
                        rotVelocity: { x: (Math.random()-0.5)*0.03, y: (Math.random()-0.5)*0.03 }
                    });
                });
            });
        }

        // --- äº¤äº’ä¸çŠ¶æ€ ---
        let state = {
            mode: 'TREE', 
            pinching: false, pinchX: 0, pinchY: 0, pinchStabilityCounter: 0,
            lastColorSwitch: 0,
            lastHandX: 0.5, smoothHandX: 0.5, lastHandY: 0.5, smoothHandY: 0.5,
            isSwiping: false, rotVelocityX: 0, rotVelocityY: 0.002
        };

        // ç›¸æœºç›®æ ‡ä½ç½®ï¼ˆç”¨äºå¹³æ»‘è¿‡æ¸¡ï¼‰
        const cameraTarget = {
            x: 0,
            y: cameraY,
            z: cameraZ,
            fov: cameraFOV
        };

        function switchMode(newMode) {
            if (state.pinching || state.isSwiping) return;
            if (state.mode === newMode) return;
            state.mode = newMode;
            
            instances.forEach(inst => { 
                if (newMode === 'TREE') inst.targetPos = inst.posTree;
                else if (newMode === 'CLOUD') inst.targetPos = inst.posCloud;
                else if (newMode === 'TEXT') inst.targetPos = inst.posText;
            });
            
            photoInstances.forEach(inst => { 
                if (newMode === 'TREE') inst.targetPos = inst.posTree;
                else if (newMode === 'CLOUD') inst.targetPos = inst.posCloud;
                else inst.targetPos = inst.posCloud;
            });

            if (newMode === 'CLOUD') {
                topperState.posCloud.set((Math.random()-0.5)*30, (Math.random()-0.5)*20 + 10, (Math.random()-0.5)*20);
                topperState.targetPos.copy(topperState.posCloud);
                // æ¢å¤é»˜è®¤ç›¸æœºä½ç½®
                cameraTarget.y = cameraY;
                cameraTarget.z = cameraZ;
                cameraTarget.fov = cameraFOV;
            } else if (newMode === 'TEXT') {
                // è°ƒæ•´ç›¸æœºä»¥ç¡®ä¿æ–‡å­—å®Œæ•´æ˜¾ç¤ºï¼ˆè€ƒè™‘å­—æ¯é—´è·åçš„å®½åº¦å¢åŠ å’Œè¾¹è·è¦æ±‚ï¼‰
                const textConfig = getTextConfig();
                
                // æ ¹æ®æ–‡å­—é…ç½®åŠ¨æ€è®¡ç®—æ ‘é¡¶æ˜Ÿä½ç½®ï¼Œç¡®ä¿åœ¨"Merry"ä¸Šæ–¹ä¿æŒä¸€å®šè·ç¦»
                // "Merry"ä½ç½®æ˜¯ y1 = size * 0.7ï¼ˆä¸­å¿ƒä½ç½®ï¼‰ï¼Œ"Merry"æ–‡å­—é«˜åº¦çº¦ä¸º size
                // "Merry"é¡¶éƒ¨ä½ç½® â‰ˆ y1 + size/2 = size * 0.7 + size * 0.5 = size * 1.2
                // æ ‘é¡¶æ˜Ÿä¸­å¿ƒåº”è¯¥åœ¨"Merry"é¡¶éƒ¨ä¸Šæ–¹ï¼ŒåŠ ä¸Šé—´è·ï¼ˆsize * 0.5ï¼‰å’Œæ ‘é¡¶æ˜ŸåŠå¾„ï¼ˆ1.5ï¼‰
                // è¿™æ ·ç¡®ä¿æ ‘é¡¶æ˜Ÿåº•éƒ¨ä¸ä¼šä¸"Merry"é‡åˆ
                const merryTop = textConfig.y1 + textConfig.size * 0.5; // "Merry"é¡¶éƒ¨
                const spacing = textConfig.size * 0.5; // é—´è·ï¼ˆéšæ–‡å­—å¤§å°è°ƒæ•´ï¼‰
                const topperRadius = 1.5; // æ ‘é¡¶æ˜ŸåŠå¾„
                const topperY = merryTop + spacing + topperRadius;
                topperState.posText.set(0, topperY, 0);
                topperState.targetPos.copy(topperState.posText); // å¤åˆ¶å€¼è€Œä¸æ˜¯å¼•ç”¨
                // åœ¨æ–‡å­—æ¨¡å¼ä¸‹ï¼Œç«‹å³è®¾ç½®å½“å‰ä½ç½®ï¼Œé¿å…å¹³æ»‘è¿‡æ¸¡å¯¼è‡´çš„å»¶è¿Ÿ
                topperState.currentPos.copy(topperState.targetPos);
                const textHeight = Math.abs(textConfig.y1 - textConfig.y2) + textConfig.size * 1.5; // ä¼°ç®—æ–‡å­—æ€»é«˜åº¦
                const aspect = window.innerWidth / window.innerHeight;
                
                // ç¡®å®šè¾¹è·è¦æ±‚ï¼ˆåƒç´ å€¼ï¼‰- ä¸getTextConfigä¸­çš„å€¼ä¿æŒä¸€è‡´
                const marginPx = isMobile ? 12 : (window.innerWidth <= 1024 ? 20 : 40);
                const marginRatio = (marginPx * 2) / window.innerWidth; // è¾¹è·å å±å¹•å®½åº¦çš„æ¯”ä¾‹
                const availableScreenWidth = window.innerWidth - marginPx * 2; // å¯ç”¨å±å¹•å®½åº¦
                
                // ä¼°ç®—æ–‡å­—åœ¨3Dç©ºé—´ä¸­çš„å®é™…å®½åº¦ï¼ˆ"CHRISTMAS"æ˜¯9ä¸ªå­—æ¯ï¼Œè€ƒè™‘å­—æ¯é—´è·ï¼‰
                // ä½¿ç”¨æ›´å‡†ç¡®çš„ä¼°ç®—ï¼šæ¯ä¸ªå­—æ¯å®½åº¦çº¦ä¸ºsizeçš„0.65å€ï¼ŒåŠ ä¸Šé—´è·
                const letterWidth = textConfig.size * 0.65;
                const letterSpacing3D = textConfig.letterSpacing * textConfig.size * 2;
                const estimatedTextWidth3D = letterWidth * 9 + letterSpacing3D * 8; // 9ä¸ªå­—æ¯ï¼Œ8ä¸ªé—´è·
                
                let targetY = 0; // æ–‡å­—å±…ä¸­ï¼Œç›¸æœºä¹Ÿå±…ä¸­
                let targetFOV = cameraFOV;
                let targetZ;
                
                // ç§»åŠ¨ç«¯ç‰¹æ®Šå¤„ç†
                if (isMobile) {
                    if (isLandscape) {
                        targetFOV = 72;
                    } else {
                        targetFOV = 65;
                    }
                } else if (isTablet) {
                    targetFOV = 58;
                }
                
                // æ ¹æ®æ–‡å­—å®½åº¦å’Œè¾¹è·è¦æ±‚ç²¾ç¡®è®¡ç®—ç›¸æœºè·ç¦»
                // åœ¨é€è§†æŠ•å½±ä¸­ï¼Œç‰©ä½“åœ¨å±å¹•ä¸Šçš„æŠ•å½±å®½åº¦ = (ç‰©ä½“å®½åº¦ / è·ç¦») * (2 * è·ç¦» * tan(FOV/2))
                // ç®€åŒ–ï¼šæŠ•å½±å®½åº¦ = ç‰©ä½“å®½åº¦ * 2 * tan(FOV/2)
                // æˆ‘ä»¬éœ€è¦ï¼šæŠ•å½±å®½åº¦ <= å¯ç”¨å±å¹•å®½åº¦
                // æ‰€ä»¥ï¼šç‰©ä½“å®½åº¦ * 2 * tan(FOV/2) <= å¯ç”¨å±å¹•å®½åº¦
                // å³ï¼šè·ç¦» >= (ç‰©ä½“å®½åº¦ * 2 * tan(FOV/2)) / å¯ç”¨å±å¹•å®½åº¦ * å±å¹•å®½åº¦
                
                const fovRad = THREE.MathUtils.degToRad(targetFOV);
                const tanHalfFov = Math.tan(fovRad / 2);
                
                // è®¡ç®—åœ¨è·ç¦»1å¤„çš„è§†å£å®½åº¦ï¼ˆä»¥3Då•ä½ï¼‰
                const viewportWidthAtDistance1 = 2 * tanHalfFov * aspect; // aspect = width/height
                
                // åœ¨è·ç¦»targetZå¤„ï¼Œè§†å£å®½åº¦ = viewportWidthAtDistance1 * targetZ
                // æ–‡å­—åœ¨å±å¹•ä¸Šçš„æŠ•å½±å®½åº¦ = (estimatedTextWidth3D / targetZ) * (viewportWidthAtDistance1 * targetZ)
                // ç®€åŒ–ï¼šæŠ•å½±å®½åº¦ = estimatedTextWidth3D * viewportWidthAtDistance1
                // æˆ‘ä»¬éœ€è¦ï¼šæŠ•å½±å®½åº¦ <= availableScreenWidth / window.innerWidth * viewportWidthAtDistance1 * targetZ
                // å³ï¼šestimatedTextWidth3D * viewportWidthAtDistance1 <= (availableScreenWidth / window.innerWidth) * viewportWidthAtDistance1 * targetZ
                // æ‰€ä»¥ï¼štargetZ >= estimatedTextWidth3D * window.innerWidth / availableScreenWidth
                
                // æ›´å‡†ç¡®çš„è®¡ç®—ï¼šè€ƒè™‘é€è§†æŠ•å½±
                // åœ¨è·ç¦»targetZå¤„ï¼Œå±å¹•ä¸Šçš„1åƒç´ å¯¹åº”3Dç©ºé—´ä¸­çš„ (viewportWidthAtDistance1 * targetZ) / window.innerWidth
                // æ‰€ä»¥ï¼šestimatedTextWidth3D / ((viewportWidthAtDistance1 * targetZ) / window.innerWidth) <= availableScreenWidth
                // å³ï¼šestimatedTextWidth3D * window.innerWidth / (viewportWidthAtDistance1 * targetZ) <= availableScreenWidth
                // æ‰€ä»¥ï¼štargetZ >= estimatedTextWidth3D * window.innerWidth / (viewportWidthAtDistance1 * availableScreenWidth)
                
                const calculatedZ = (estimatedTextWidth3D * window.innerWidth) / (viewportWidthAtDistance1 * availableScreenWidth);
                
                // ä½¿ç”¨åŸºäºé«˜åº¦çš„è®¡ç®—ä½œä¸ºå¤‡é€‰ï¼Œå–è¾ƒå¤§å€¼
                let baseZ = textHeight * 2.0;
                
                // ç§»åŠ¨ç«¯ï¼šä½¿ç”¨æ›´ä¿å®ˆçš„è·ç¦»ä»¥ç¡®ä¿è¾¹è·ï¼ŒåŒæ—¶è®©æ–‡å­—å°½å¯èƒ½å¤§
                if (isMobile) {
                    if (isLandscape) {
                        // æ¨ªå±ï¼šä½¿ç”¨è®¡ç®—å€¼å’ŒåŸºäºé«˜åº¦çš„è¾ƒå¤§å€¼ï¼Œå†å¢åŠ ä¸€äº›ä»¥ç¡®ä¿è¾¹è·
                        targetZ = Math.max(calculatedZ, baseZ, textHeight * 2.5);
                    } else {
                        // ç«–å±ï¼šä½¿ç”¨è®¡ç®—å€¼å’ŒåŸºäºé«˜åº¦çš„è¾ƒå¤§å€¼ï¼Œå†å¢åŠ ä¸€äº›ä»¥ç¡®ä¿è¾¹è·
                        targetZ = Math.max(calculatedZ, baseZ, textHeight * 2.6);
                    }
                } else if (isTablet) {
                    targetZ = Math.max(calculatedZ, baseZ, textHeight * 2.2);
                } else {
                    targetZ = Math.max(calculatedZ, baseZ);
                }
                
                // ç¡®ä¿æœ€å°è·ç¦»
                const minDistance = isMobile ? 45 : 40;
                targetZ = Math.max(targetZ, minDistance);
                
                cameraTarget.y = targetY;
                cameraTarget.z = targetZ;
                cameraTarget.fov = targetFOV;
            } else {
                topperState.targetPos.copy(topperState.posTree);
                // æ¢å¤é»˜è®¤ç›¸æœºä½ç½®
                cameraTarget.y = cameraY;
                cameraTarget.z = cameraZ;
                cameraTarget.fov = cameraFOV;
            }
        }

        function switchColor() {
            if (state.pinching) return; 
            const now = Date.now();
            if (now - state.lastColorSwitch > 1500) { 
                currentPaletteIndex = (currentPaletteIndex + 1) % PALETTES.length;
                applyColors(currentPaletteIndex);
                state.lastColorSwitch = now;
                topperMat.emissiveIntensity = 3;
                setTimeout(() => topperMat.emissiveIntensity = 1, 200);
            }
        }

        // --- æ‰‹åŠ¿è¯†åˆ« ---
        const videoElement = document.getElementById('webcam_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        
        // ===== æ‘„åƒå¤´ & ç”»å¸ƒé€šç”¨åˆå§‹åŒ–ï¼ˆä¸»æµæœºå‹å…¼å®¹ï¼‰ =====
        // iOS ä¸Šéœ€è¦æ˜¾å¼è®¾ç½®è¿™äº›å±æ€§ï¼Œé¿å…å¼ºåˆ¶å…¨å±å’Œæ’­æ”¾å¤±è´¥
        videoElement.setAttribute('playsinline', 'true');
        videoElement.setAttribute('autoplay', 'true');
        videoElement.setAttribute('muted', 'true');
        videoElement.playsInline = true;
        videoElement.autoplay = true;
        videoElement.muted = true;
        
        // åŒæ­¥ canvas åƒç´ å°ºå¯¸åˆ°çœŸå®è§†é¢‘å°ºå¯¸ï¼Œé¿å…æ‹‰ä¼¸å’Œæ£€æµ‹åç§»
        videoElement.addEventListener('loadedmetadata', () => {
            const w = videoElement.videoWidth || 640;
            const h = videoElement.videoHeight || 480;
            canvasElement.width = w;
            canvasElement.height = h;
        });
        const statusText = document.getElementById('gesture-status');

        function detectGesture(landmarks) {
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x-p2.x,2) + Math.pow(p1.y-p2.y,2));
            const isFingerOpen = (tipIdx, pipIdx) => landmarks[tipIdx].y < landmarks[pipIdx].y;
            
            if (dist(thumbTip, indexTip) < 0.05) return "PINCH";
            
            const idxOpen = isFingerOpen(8, 6);
            const midOpen = isFingerOpen(12, 10);
            const ringOpen = isFingerOpen(16, 14);
            const pinkyOpen = isFingerOpen(20, 18);

            if (idxOpen && midOpen && !ringOpen && !pinkyOpen) {
                if (dist(indexTip, middleTip) > 0.05) return "VICTORY";
            }
            if (idxOpen && !midOpen && !ringOpen && !pinkyOpen) return "POINTING"; 
            if (!idxOpen && !midOpen && !ringOpen && !pinkyOpen) return "FIST";
            
            let openCount = 0;
            if (idxOpen) openCount++; if (midOpen) openCount++; if (ringOpen) openCount++; if (pinkyOpen) openCount++;
            if (openCount >= 4) return "OPEN";
            return "NONE";
        }

        // Hands ä½¿ç”¨æœ¬åœ°èµ„æºç›®å½•ï¼šè¯·å°† @mediapipe/hands åŒ…å†…çš„æ¨¡å‹/wasm æ–‡ä»¶ä¹Ÿæ”¾åˆ° ./libs/mediapipe/hands/ ä¸‹
        const hands = new Hands({locateFile: (file) => `./libs/mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            // é™ä½ä¸€ç‚¹é˜ˆå€¼ï¼ŒçœŸæœºä¸Šæ›´å®¹æ˜“è¯†åˆ«åˆ°æ‰‹
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(results => {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1});

                state.smoothHandX = THREE.MathUtils.lerp(state.smoothHandX, landmarks[9].x, 0.2);
                state.smoothHandY = THREE.MathUtils.lerp(state.smoothHandY, landmarks[9].y, 0.2);
                
                const deltaX = state.smoothHandX - state.lastHandX;
                const deltaY = state.smoothHandY - state.lastHandY;
                state.lastHandX = state.smoothHandX; state.lastHandY = state.smoothHandY;

                const gesture = detectGesture(landmarks);
                state.pinchX = (landmarks[4].x + landmarks[8].x) - 1; 
                state.pinchY = -((landmarks[4].y + landmarks[8].y) - 1);

                if (state.mode === 'CLOUD' && (Math.abs(deltaX) > 0.03 || Math.abs(deltaY) > 0.03)) { 
                    state.isSwiping = true;
                    state.rotVelocityY += deltaX * 2.5; 
                    state.rotVelocityX += deltaY * 2.5;
                    statusText.innerText = `Gesture: SWIPE (Rotating)`;
                } else {
                    state.isSwiping = false;
                }

                if (gesture === "PINCH") {
                    state.pinchStabilityCounter++;
                    if (state.pinchStabilityCounter > 2) {
                        state.pinching = true;
                        statusText.innerText = "Gesture: PINCH (Locked)";
                    }
                } else {
                    state.pinchStabilityCounter = 0;
                    state.pinching = false;
                    if (!state.isSwiping) statusText.innerText = `Gesture: ${gesture}`;
                }

                if (!state.pinching && !state.isSwiping) {
                    switch(gesture) {
                        case "OPEN": switchMode('CLOUD'); break;
                        case "FIST": switchMode('TREE'); break;
                        case "VICTORY": switchColor(); break;
                        case "POINTING": switchMode('TEXT'); break;
                    }
                }
            } else {
                statusText.innerText = "No Hand";
                state.pinching = false; state.isSwiping = false;
            }
            canvasCtx.restore();
        });
        
        // ===== ç»Ÿä¸€æ‘„åƒå¤´å¯åŠ¨é€»è¾‘ï¼šæ ‡å‡† getUserMediaï¼Œå…¼å®¹ä¸»æµæµè§ˆå™¨(iOS Safari/Chrome, Android, æ¡Œé¢) =====
        let cameraStream = null;
        let handLoopRunning = false;

        async function startHandLoop() {
            if (handLoopRunning) return;
            handLoopRunning = true;
            const loop = async () => {
                // ç­‰å¾…è§†é¢‘çœŸçš„æœ‰ç”»é¢å†é€å…¥æ¨¡å‹
                if (videoElement.readyState >= 2) {
                    try {
                        await hands.send({ image: videoElement });
                    } catch (err) {
                        console.warn('hands.send error', err);
                    }
                }
                if (handLoopRunning) requestAnimationFrame(loop);
            };
            requestAnimationFrame(loop);
        }

        async function startCamera() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error('getUserMedia not supported on this browser.');
                statusText.innerText = 'Camera Not Supported';
                return;
            }

            // å°è¯•ä¼˜å…ˆä½¿ç”¨å‰ç½®æ‘„åƒå¤´ï¼›å¦‚æœå¤±è´¥ï¼Œå†é€€å›å®½æ¾çº¦æŸ
            const constraintsList = [
                {
                    video: {
                        facingMode: { ideal: 'user' },
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                },
                {
                    video: true
                }
            ];

            for (let i = 0; i < constraintsList.length; i++) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraintsList[i]);
                    cameraStream = stream;
                    videoElement.srcObject = stream;

                    // iOS éœ€è¦ç”¨æˆ·æ‰‹åŠ¿å playï¼›è¿™é‡Œåœ¨æŒ‰é’®ç‚¹å‡»åè°ƒç”¨ï¼Œç¬¦åˆè¦æ±‚
                    await videoElement.play().catch(e => {
                        console.warn('video.play failed', e);
                    });

                    startHandLoop();
                    return;
                } catch (err) {
                    console.warn('getUserMedia failed with constraints', constraintsList[i], err);
                    if (i === constraintsList.length - 1) {
                        statusText.innerText = 'Camera Error';
                    }
                }
            }
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            document.querySelector('.btn-group').style.display = 'none';
            document.getElementById('cam-container').style.display = 'block';
            playMusic(0);
            startCamera();
        });

        window.addEventListener('mousedown', () => switchMode('TREE'));
        window.addEventListener('mouseup', () => switchMode('CLOUD'));
        
        // ç§»åŠ¨ç«¯åŒå‡»é€€å‡ºå…¨å±
        let lastTapTime = 0;
        let tapCount = 0;
        window.addEventListener('touchstart', (e) => {
            const currentTime = Date.now();
            const tapLength = currentTime - lastTapTime;
            
            if (tapCount === 0) {
                tapCount = 1;
            } else if (tapCount === 1 && tapLength < 300) {
                // åŒå‡»æ£€æµ‹
                tapCount = 0;
                // å¦‚æœå½“å‰æ˜¯å…¨å±çŠ¶æ€ï¼Œé€€å‡ºå…¨å±
                if (document.fullscreenElement || 
                    document.webkitFullscreenElement || 
                    document.mozFullScreenElement || 
                    document.msFullscreenElement) {
                    toggleFullscreen();
                }
            } else {
                tapCount = 0;
            }
            
            lastTapTime = currentTime;
            
            // é‡ç½®è®¡æ•°å™¨
            setTimeout(() => {
                tapCount = 0;
            }, 300);
        });

        const clock = new THREE.Clock();
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = false; controls.enableDamping = true;
        const tempV = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (state.mode === 'TEXT') {
                state.rotVelocityX = 0; state.rotVelocityY = 0;
                treeGroup.rotation.x = THREE.MathUtils.lerp(treeGroup.rotation.x, 0, 0.1);
                treeGroup.rotation.y = THREE.MathUtils.lerp(treeGroup.rotation.y, 0, 0.1);
                treeGroup.rotation.z = THREE.MathUtils.lerp(treeGroup.rotation.z, 0, 0.1);
            } else {
                state.rotVelocityY = THREE.MathUtils.clamp(state.rotVelocityY, -0.15, 0.15);
                state.rotVelocityX = THREE.MathUtils.clamp(state.rotVelocityX, -0.10, 0.10);
                let baseSpeedY = (state.mode === 'TREE') ? 0.002 : 0.0005; 
                state.rotVelocityY = THREE.MathUtils.lerp(state.rotVelocityY, baseSpeedY, 0.03);
                state.rotVelocityX = THREE.MathUtils.lerp(state.rotVelocityX, 0, 0.05);
                treeGroup.rotation.y += state.rotVelocityY;
                treeGroup.rotation.x += state.rotVelocityX;
                treeGroup.rotation.x = THREE.MathUtils.clamp(treeGroup.rotation.x, -0.5, 0.5);
            }
            photoGroup.rotation.copy(treeGroup.rotation);
            decorGroup.rotation.y = treeGroup.rotation.y; 

            // --- Topper åŠ¨ç”» ---
            const topperSpeed = (state.mode === 'CLOUD') ? 0.05 : 0.08;
            topperState.currentPos.lerp(topperState.targetPos, topperSpeed);
            if (state.mode !== 'TREE') {
                topperState.currentPos.y += Math.sin(time * 2) * 0.02;
                topperMesh.rotation.y += 0.02;
                topperMesh.rotation.z = Math.sin(time) * 0.1;
            } else {
                topperMesh.rotation.y += 0.01;
                topperMesh.rotation.z = 0;
            }
            topperMesh.position.copy(topperState.currentPos);

            // --- ç›¸æœºä½ç½®å¹³æ»‘è¿‡æ¸¡ ---
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, cameraTarget.x, 0.05);
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, cameraTarget.y, 0.05);
            camera.position.z = THREE.MathUtils.lerp(camera.position.z, cameraTarget.z, 0.05);
            camera.fov = THREE.MathUtils.lerp(camera.fov, cameraTarget.fov, 0.05);
            camera.updateProjectionMatrix();

            // --- è£…é¥°åŠ¨ç”» ---
            if(state.mode === 'TREE') {
                spiralMat.opacity = THREE.MathUtils.lerp(spiralMat.opacity, 0.6, 0.05);
                floorRing.material.opacity = THREE.MathUtils.lerp(floorRing.material.opacity, 0.4, 0.05);
                
                // æ˜Ÿå°˜ç³»ç»Ÿæ·¡å…¥
                galaxyMat.opacity = THREE.MathUtils.lerp(galaxyMat.opacity, 0.8, 0.02);
                lineMat.opacity = THREE.MathUtils.lerp(lineMat.opacity, 0.3, 0.02);
            } else {
                spiralMat.opacity = THREE.MathUtils.lerp(spiralMat.opacity, 0, 0.1);
                floorRing.material.opacity = THREE.MathUtils.lerp(floorRing.material.opacity, 0, 0.1);
                
                // æ˜Ÿå°˜ç³»ç»Ÿæ·¡å‡º
                galaxyMat.opacity = THREE.MathUtils.lerp(galaxyMat.opacity, 0, 0.05);
                lineMat.opacity = THREE.MathUtils.lerp(lineMat.opacity, 0, 0.05);
            }

            // æ›´æ–°æ˜Ÿå°˜æ—‹è½¬ (å³ä½¿çœ‹ä¸è§ä¹Ÿåœ¨è½¬ï¼Œä¿è¯åˆ‡å›æ¥æ—¶ä¸çªå…€)
            galaxySystem.rotation.y += 0.001; 
            
            // æ›´æ–°æµæ˜Ÿé›¨
            if(lineMat.opacity > 0.01) {
                const positions = shootingLines.geometry.attributes.position.array;
                for(let i=0; i<lineCount; i++) {
                    // çº¿æ¡æ²¿ Y è½´ (å‚ç›´) æˆ– Z è½´ (çºµæ·±) ç§»åŠ¨
                    // è¿™é‡Œè®©å®ƒä»¬åƒé›¨ä¸€æ ·è½ä¸‹ï¼Œæˆ–è€…åƒç©¿æ¢­ä¸€æ ·é£è¿‡
                    // æˆ‘ä»¬é€‰æ‹©ï¼šå‘ Z è½´è´Ÿæ–¹å‘é£ (é£å‘å±å¹•æ·±å¤„)
                    positions[i*6 + 2] -= lineSpeed[i]; // Head Z
                    positions[i*6 + 5] -= lineSpeed[i]; // Tail Z
                    
                    if(positions[i*6 + 2] < -150) {
                        const newZ = 150;
                        const newX = (Math.random()-0.5) * 300;
                        const newY = (Math.random()-0.5) * 300;
                        positions[i*6] = newX; positions[i*6+1] = newY; positions[i*6+2] = newZ;
                        positions[i*6+3] = newX; positions[i*6+4] = newY - 5; positions[i*6+5] = newZ + 10;
                    }
                }
                shootingLines.geometry.attributes.position.needsUpdate = true;
            }

            if(spiralMat.opacity > 0.01) {
                const spiralPosArr = spiralGeo.attributes.position.array;
                for(let i=0; i<spiralCount; i++) {
                    const ratio = i / spiralCount;
                    const angle = ratio * Math.PI * 8 + time * 0.5; 
                    const radius = 9 - ratio * 8; 
                    const y = ratio * CONFIG.height - CONFIG.height/2;
                    const offset = (i%2===0) ? 0 : Math.PI;
                    spiralPosArr[i*3] = Math.cos(angle + offset) * radius;
                    spiralPosArr[i*3+1] = y;
                    spiralPosArr[i*3+2] = Math.sin(angle + offset) * radius;
                }
                spiralGeo.attributes.position.needsUpdate = true;
                const s = 1 + Math.sin(time * 2) * 0.05;
                floorRing.scale.set(s, s, s);
            }

            // --- é›ªèŠ±ç³»ç»Ÿ ---
            const isTextMode = state.mode === 'TEXT';
            if (isTextMode) {
                snowMat.opacity = THREE.MathUtils.lerp(snowMat.opacity, 0.9, 0.02);
                textSnowMat.opacity = THREE.MathUtils.lerp(textSnowMat.opacity, 1.2, 0.03);
            } else {
                snowMat.opacity = THREE.MathUtils.lerp(snowMat.opacity, 0, 0.05);
                textSnowMat.opacity = THREE.MathUtils.lerp(textSnowMat.opacity, 0, 0.06);
            }

            if (snowMat.opacity > 0.01) {
                const positions = snowGeo.attributes.position.array;
                for(let i=0; i<snowCount; i++) {
                    positions[i*3+1] += snowVel[i].y;
                    positions[i*3] += Math.sin(time + positions[i*3+1]*0.05) * 0.02;
                    if (positions[i*3+1] < -30) {
                        positions[i*3+1] = 30;
                        positions[i*3] = (Math.random()-0.5) * 100;
                        positions[i*3+2] = (Math.random()-0.5) * 50 + 20;
                    }
                }
                snowGeo.attributes.position.needsUpdate = true;
            }

            if (textSnowMat.opacity > 0.01) {
                const positions = textSnowGeo.attributes.position.array;
                for (let i = 0; i < textSnowCount; i++) {
                    positions[i*3]   += textSnowVel[i].x;
                    positions[i*3+1] += textSnowVel[i].y;
                    positions[i*3+2] += textSnowVel[i].z;
                    // å¾ªç¯ä¸‹è½
                    if (positions[i*3+1] < -20) {
                        positions[i*3]   = (Math.random()-0.5) * 80;
                        positions[i*3+1] = 25 + Math.random() * 45;
                        positions[i*3+2] = (Math.random()-0.5) * 45;
                    }
                }
                textSnowGeo.attributes.position.needsUpdate = true;
            }

            // --- ç²’å­åŠ¨ç”» ---
            const isCloud = state.mode === 'CLOUD';
            const moveSpeed = isCloud ? CONFIG.floatSpeed : CONFIG.restoreSpeed;

            instances.forEach(inst => {
                inst.currentPos.lerp(inst.targetPos, moveSpeed);
                inst.currentPos.y += Math.sin(time*2 + inst.meshIndex)*0.01;
                
                if(state.mode === 'TEXT') {
                     inst.rotation.x *= 0.9; inst.rotation.y *= 0.9;
                } else if(isCloud) {
                    inst.rotation.x += inst.rotSpeed.x; inst.rotation.y += inst.rotSpeed.y;
                } else {
                    inst.rotation.x += inst.rotSpeed.x * 0.1;
                }
                
                dummy.position.copy(inst.currentPos);
                dummy.rotation.set(inst.rotation.x, inst.rotation.y, inst.rotation.z);
                dummy.scale.setScalar(1);
                dummy.updateMatrix();
                const mesh = inst.type === 'sphere' ? sphereMesh : cubeMesh;
                mesh.setMatrixAt(inst.meshIndex, dummy.matrix);
            });
            sphereMesh.instanceMatrix.needsUpdate = true;
            cubeMesh.instanceMatrix.needsUpdate = true;

            // --- ç…§ç‰‡åŠ¨ç”» ---
            let closestIdx = -1; let minDist = Infinity; 
            if (state.pinching && state.mode === 'CLOUD' && photoInstances.length > 0) {
                photoInstances.forEach((inst, i) => {
                    inst.mesh.getWorldPosition(tempV);
                    tempV.project(camera); 
                    if (tempV.z < 1) {
                        const dist = Math.sqrt(Math.pow(tempV.x - state.pinchX, 2) + Math.pow(tempV.y - state.pinchY, 2));
                        if (dist < minDist) { minDist = dist; closestIdx = i; }
                    }
                });
            }

            photoInstances.forEach((inst, i) => {
                inst.currentPos.lerp(inst.targetPos, moveSpeed);
                if(isCloud) {
                    inst.currentPos.y += Math.sin(time*1.5 + i)*0.01;
                    inst.mesh.rotation.x += inst.rotVelocity.x; inst.mesh.rotation.y += inst.rotVelocity.y;
                } else {
                    inst.currentPos.y += Math.sin(time*1.5 + i)*0.01;
                    inst.mesh.rotation.x = THREE.MathUtils.lerp(inst.mesh.rotation.x, inst.rotationTree.x, 0.1);
                    inst.mesh.rotation.y = THREE.MathUtils.lerp(inst.mesh.rotation.y, inst.rotationTree.y, 0.1);
                    inst.mesh.rotation.z = THREE.MathUtils.lerp(inst.mesh.rotation.z, inst.rotationTree.z, 0.1);
                }
                inst.mesh.position.copy(inst.currentPos);

                const isSelected = state.pinching && i === closestIdx;
                let targetScale = 0;
                if (state.mode === 'CLOUD') {
                    targetScale = isSelected ? 25.0 : inst.baseScale;
                    inst.mesh.visible = true; 
                } else {
                    targetScale = 0;
                }
                inst.currentScale = THREE.MathUtils.lerp(inst.currentScale, targetScale, 0.1);
                if (state.mode !== 'CLOUD' && inst.currentScale < 0.01) inst.mesh.visible = false;
                inst.mesh.scale.setScalar(inst.currentScale);

                const photoMesh = inst.mesh.children[0];
                const borderMat = inst.mesh.material;
                const photoMat = photoMesh ? photoMesh.material : null;
                
                if (isSelected && state.mode === 'CLOUD') {
                    inst.mesh.lookAt(camera.position); 
                    inst.mesh.renderOrder = 9999;
                    if(photoMesh) photoMesh.renderOrder = 10000;
                    if(borderMat) { borderMat.depthTest = false; borderMat.depthWrite = false; }
                    if(photoMat) { photoMat.depthTest = false; photoMat.depthWrite = false; photoMat.fog = false; photoMat.toneMapped = false; }
                } else {
                    inst.mesh.renderOrder = 0;
                    if(photoMesh) photoMesh.renderOrder = 0;
                    if(borderMat) { borderMat.depthTest = true; borderMat.depthWrite = true; }
                    if(photoMat) { photoMat.depthTest = true; photoMat.depthWrite = true; photoMat.fog = true; photoMat.toneMapped = true; }
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            // é‡æ–°æ£€æµ‹è®¾å¤‡ç±»å‹
            const newIsMobile = window.innerWidth <= 767;
            const newIsTablet = window.innerWidth > 767 && window.innerWidth <= 1024;
            const newIsLandscape = window.innerWidth > window.innerHeight;
            
            // æ›´æ–°ç›¸æœºå‚æ•°
            let newFOV = 45;
            let newZ = 55;
            let newY = 5;
            
            if (newIsMobile) {
                if (newIsLandscape) {
                    newFOV = 60;
                    newZ = 45;
                    newY = 3;
                } else {
                    newFOV = 55;
                    newZ = 50;
                    newY = 4;
                }
            } else if (newIsTablet) {
                newFOV = 50;
                newZ = 52;
                newY = 4.5;
            }
            
            // å¦‚æœå½“å‰æ˜¯æ–‡å­—æ¨¡å¼ï¼Œæ ¹æ®æ–°çš„å±å¹•å°ºå¯¸é‡æ–°è®¡ç®—ç›¸æœºä½ç½®å’Œæ ‘é¡¶æ˜Ÿä½ç½®
            if (state.mode === 'TEXT') {
                const textConfig = getTextConfig();
                
                // æ›´æ–°æ ‘é¡¶æ˜Ÿä½ç½®ä»¥é€‚åº”æ–°çš„æ–‡å­—é…ç½®
                const merryTop = textConfig.y1 + textConfig.size * 0.5; // "Merry"é¡¶éƒ¨
                const spacing = textConfig.size * 0.5; // é—´è·ï¼ˆéšæ–‡å­—å¤§å°è°ƒæ•´ï¼‰
                const topperRadius = 1.5; // æ ‘é¡¶æ˜ŸåŠå¾„
                const topperY = merryTop + spacing + topperRadius;
                topperState.posText.set(0, topperY, 0);
                topperState.targetPos.copy(topperState.posText); // å¤åˆ¶å€¼è€Œä¸æ˜¯å¼•ç”¨
                // ç«‹å³æ›´æ–°å½“å‰ä½ç½®ä»¥é€‚åº”æ–°çš„å±å¹•å°ºå¯¸
                topperState.currentPos.copy(topperState.targetPos);
                
                const textHeight = Math.abs(textConfig.y1 - textConfig.y2) + textConfig.size * 1.5;
                const aspect = window.innerWidth / window.innerHeight;
                
                // ç¡®å®šè¾¹è·è¦æ±‚ï¼ˆåƒç´ å€¼ï¼‰- ä¸getTextConfigä¸­çš„å€¼ä¿æŒä¸€è‡´
                const marginPx = newIsMobile ? 12 : (window.innerWidth <= 1024 ? 20 : 40);
                const availableScreenWidth = window.innerWidth - marginPx * 2; // å¯ç”¨å±å¹•å®½åº¦
                
                // ä¼°ç®—æ–‡å­—åœ¨3Dç©ºé—´ä¸­çš„å®é™…å®½åº¦
                const letterWidth = textConfig.size * 0.65;
                const letterSpacing3D = textConfig.letterSpacing * textConfig.size * 2;
                const estimatedTextWidth3D = letterWidth * 9 + letterSpacing3D * 8;
                
                let targetY = 0;
                let targetFOV = newFOV;
                let targetZ;
                
                // ç§»åŠ¨ç«¯ç‰¹æ®Šå¤„ç†
                if (newIsMobile) {
                    if (newIsLandscape) {
                        targetFOV = 72;
                    } else {
                        targetFOV = 65;
                    }
                } else if (newIsTablet) {
                    targetFOV = 58;
                }
                
                // æ ¹æ®æ–‡å­—å®½åº¦å’Œè¾¹è·è¦æ±‚ç²¾ç¡®è®¡ç®—ç›¸æœºè·ç¦»
                const fovRad = THREE.MathUtils.degToRad(targetFOV);
                const tanHalfFov = Math.tan(fovRad / 2);
                const viewportWidthAtDistance1 = 2 * tanHalfFov * aspect;
                
                const calculatedZ = (estimatedTextWidth3D * window.innerWidth) / (viewportWidthAtDistance1 * availableScreenWidth);
                let baseZ = textHeight * 2.0;
                
                // ç§»åŠ¨ç«¯ï¼šä½¿ç”¨æ›´ä¿å®ˆçš„è·ç¦»ä»¥ç¡®ä¿è¾¹è·ï¼ŒåŒæ—¶è®©æ–‡å­—å°½å¯èƒ½å¤§
                if (newIsMobile) {
                    if (newIsLandscape) {
                        targetZ = Math.max(calculatedZ, baseZ, textHeight * 2.5);
                    } else {
                        targetZ = Math.max(calculatedZ, baseZ, textHeight * 2.6);
                    }
                } else if (newIsTablet) {
                    targetZ = Math.max(calculatedZ, baseZ, textHeight * 2.2);
                } else {
                    targetZ = Math.max(calculatedZ, baseZ);
                }
                
                const minDistance = newIsMobile ? 45 : 40;
                targetZ = Math.max(targetZ, minDistance);
                
                cameraTarget.y = targetY;
                cameraTarget.z = targetZ;
                cameraTarget.fov = targetFOV;
            } else {
                // éæ–‡å­—æ¨¡å¼ï¼Œä½¿ç”¨é»˜è®¤ç›¸æœºä½ç½®
                cameraTarget.y = newY;
                cameraTarget.z = newZ;
                cameraTarget.fov = newFOV;
            }
            
            camera.fov = cameraTarget.fov;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.position.set(0, cameraTarget.y, cameraTarget.z);
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>