<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Christmas Galaxy - Hyper Cosmic</title>
    <!-- PWAé…ç½® -->
    <link rel="manifest" href="manifest.json">
    <!-- iOSç‰¹å®šé…ç½® -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Christmas Galaxy">
    <link rel="apple-touch-icon" href="assets/textures/snowflake1.png">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Times New Roman', serif; transition: cursor 0.3s; }

        /* éšè—UIæ—¶çš„æ ·å¼ (å…¨å±æ—¶) */
        body.ui-hidden { cursor: none; }
        body.ui-hidden #ui-container,
        body.ui-hidden .btn-group,
        body.ui-hidden #cam-container,
        body.ui-hidden #main-title { /* å¢åŠ æ ‡é¢˜éšè— */
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        /* --- ä¿®æ”¹ï¼šæ ‡é¢˜å±…ä¸­æ ·å¼ --- */
        #main-title {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none; /* å…è®¸ç‚¹å‡»æ ‡é¢˜ä¸‹æ–¹çš„3Då…ƒç´  */

            color: #ffeb3b;
            font-size: 3rem;
            margin: 0;
            letter-spacing: 5px;
            text-shadow: 0 0 10px rgba(255,215,0,0.6), 0 0 20px rgba(255,0,0,0.4);
            text-transform: uppercase;
            transition: opacity 0.5s;
        }

        /* å·¦ä¸Šè§’ UI å®¹å™¨ (ä»…åŒ…å«è¯´æ˜ä¹¦å’ŒéŸ³ä¹çŠ¶æ€) */
        #ui-container {
            /* å‘ä¸‹ç§»åŠ¨ï¼Œé¿å…ä¸ "Christmas Galaxy" æ ‡é¢˜é‡å  */
            position: absolute; top: 80px; left: 20px; width: auto;
            text-align: left; pointer-events: none; z-index: 10; transition: opacity 0.5s;
        }

        .instructions {
            color: #eee; font-size: 0.95rem; margin-top: 5px; font-family: sans-serif;
            background: rgba(0,0,0,0.6); padding: 20px; border-radius: 15px; display: inline-block;
            border: 1px solid rgba(255,255,255,0.1); line-height: 1.8;
            backdrop-filter: blur(5px);
        }

        .key-point { color: #00ff00; font-weight: bold; text-transform: uppercase; }
        .music-point { color: #00d2ff; font-weight: bold; text-transform: uppercase; border: 1px solid #00d2ff; padding: 2px 6px; border-radius: 4px; }
        .fs-point { color: #ffd700; font-weight: bold; text-transform: uppercase; }

        /* æ¡Œé¢ç«¯ä¸“ç”¨å…ƒç´  - é»˜è®¤æ˜¾ç¤ºï¼Œç§»åŠ¨ç«¯éšè— */
        .desktop-only {
            display: inline;
        }
        /* ç§»åŠ¨ç«¯ / å¹³æ¿ä¸“ç”¨å…ƒç´  - é»˜è®¤éšè—ï¼Œåœ¨å°å±è®¾å¤‡ä¸Šæ˜¾ç¤º */
        .mobile-only {
            display: none;
        }

        #music-status-display {
            margin-top: 15px; font-family: monospace; font-size: 1.1rem; color: #00d2ff;
            text-shadow: 0 0 5px #00d2ff; display: none !important; /* éšè—éŸ³ä¹çŠ¶æ€æ˜¾ç¤ºï¼Œä»…æ’­æ”¾éŸ³ä¹ */
            background: rgba(0,0,0,0.8); padding: 8px 15px; border-radius: 5px;
            pointer-events: auto; cursor: pointer; border: 1px solid #00d2ff; width: fit-content;
        }
        #music-status-display:hover { background: rgba(0, 210, 255, 0.2); }

        #cam-container {
            position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px;
            border: 2px solid rgba(255,215,0,0.3); border-radius: 10px; overflow: hidden;
            z-index: 20; background: #000; display: none; transition: opacity 0.5s;
        }
        #webcam_video { position: absolute; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.5; }
        #output_canvas { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }

        #gesture-status {
            position: absolute; top: 10px; left: 10px; color: #00ff00; font-weight: bold; font-family: monospace; font-size: 16px;
            text-shadow: 0 0 2px black; z-index: 25;
        }

        /* æŒ‰é’®ç»„ï¼šå·¦ä¾§å‚ç›´å±…ä¸­ */
        .btn-group {
            position: absolute;
            top: 55%;
            left: 20px;
            transform: translateY(-50%);

            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 30;
            pointer-events: auto;
            transition: opacity 0.5s;
        }

        .magic-btn {
            width: 220px;
            display: flex;
            justify-content: center;
            align-items: center;

            padding: 15px 0;
            background: linear-gradient(45deg, #ffd700, #ffaa00);
            border: none; border-radius: 30px; color: #000; font-weight: bold; font-size: 1.1rem;
            cursor: pointer; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); transition: 0.3s;
        }
        .magic-btn:hover { transform: scale(1.05) translateX(10px); background: linear-gradient(45deg, #ffaa00, #ffd700); }
        .magic-btn.secondary { background: linear-gradient(45deg, #00d2ff, #3a7bd5); color: white; }

        #file-input-photo { display: none; }

        /* å…¨å±æŒ‰é’®æ ·å¼å·²åºŸå¼ƒï¼ˆæ”¹ä¸ºåŒå‡»å±å¹•åˆ‡æ¢å…¨å±ï¼‰ */

        /* ========== å“åº”å¼è®¾è®¡ï¼šiPad ========== */
        @media screen and (max-width: 1024px) and (min-width: 768px) {
            #main-title {
                font-size: 2.5rem;
                top: 15px;
                letter-spacing: 3px;
            }

            #ui-container {
                /* å¹³æ¿ä¸Šä¹Ÿå‘ä¸‹ç§»åŠ¨ä¸€äº›ï¼Œä¿æŒåœ¨æ ‡é¢˜ä¸‹æ–¹ */
                top: 70px;
                left: 15px;
            }

            .instructions {
                font-size: 0.85rem;
                padding: 15px;
                line-height: 1.6;
            }

            /* å¹³æ¿ç«¯ä¹Ÿéšè—æ¡Œé¢ç«¯ä¸“ç”¨å…ƒç´ ï¼Œæ˜¾ç¤ºç§»åŠ¨ç«¯ä¸“ç”¨å…ƒç´  */
            .desktop-only {
                display: none !important;
            }
            .mobile-only {
                display: inline;
            }

            #music-status-display {
                font-size: 1rem;
                padding: 6px 12px;
            }

            .btn-group {
                left: 15px;
                gap: 15px;
            }

            .magic-btn {
                width: 180px;
                padding: 12px 0;
                font-size: 1rem;
            }

            #cam-container {
                width: 200px;
                height: 150px;
                bottom: 15px;
                right: 15px;
            }

            #gesture-status {
                font-size: 14px;
            }
        }

        /* ========== å“åº”å¼è®¾è®¡ï¼šæ‰‹æœº ========== */
        @media screen and (max-width: 767px) {
            #main-title {
                font-size: 1.5rem;
                top: 10px;
                letter-spacing: 2px;
            }

            #ui-container {
                /* æ‰‹æœºç«¯å‘ä¸‹ç§»åŠ¨æ›´å¤šï¼Œé˜²æ­¢ä¸æ ‡é¢˜é‡å  */
                top: 60px;
                left: 10px;
                max-width: calc(100% - 20px);
            }

            .instructions {
                font-size: 0.7rem;
                padding: 12px;
                line-height: 1.5;
                max-width: 100%;
            }

            /* æ‰‹æœºç«¯éšè—æ¡Œé¢ç«¯ä¸“ç”¨å…ƒç´ ï¼Œæ˜¾ç¤ºç§»åŠ¨ç«¯ä¸“ç”¨å…ƒç´  */
            .desktop-only {
                display: none !important;
            }
            .mobile-only {
                display: inline;
            }

            #music-status-display {
                font-size: 0.85rem;
                padding: 6px 10px;
                margin-top: 10px;
            }

            .btn-group {
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                gap: 12px;
                width: 90%;
                max-width: 280px;
            }

            .magic-btn {
                width: 100%;
                padding: 12px 0;
                font-size: 0.95rem;
            }

            .magic-btn:hover {
                transform: scale(1.05);
            }

            #cam-container {
                width: 160px;
                height: 120px;
                bottom: 10px;
                right: 10px;
            }

            #gesture-status {
                font-size: 12px;
                top: 5px;
                left: 5px;
            }
        }

        /* ========== æ¨ªå±æ‰‹æœºç‰¹æ®Šå¤„ç† ========== */
        @media screen and (max-width: 767px) and (orientation: landscape) {
            #main-title {
                font-size: 1.2rem;
                top: 5px;
            }

            #ui-container {
                /* æ¨ªå±æ‰‹æœºä¸‹åŒæ ·ä¿æŒåœ¨æ ‡é¢˜ä¸‹æ–¹ */
                top: 50px;
                left: 5px;
            }

            .instructions {
                font-size: 0.65rem;
                padding: 8px;
                line-height: 1.4;
            }

            .btn-group {
                top: auto;
                bottom: 10px;
                left: 10px;
                transform: none;
                flex-direction: row;
                flex-wrap: wrap;
                gap: 8px;
                max-width: calc(100% - 180px);
            }

            .magic-btn {
                width: auto;
                min-width: 120px;
                padding: 8px 15px;
                font-size: 0.85rem;
            }

            #cam-container {
                width: 140px;
                height: 105px;
            }
        }

        /* ========== iPadæ¨ªå±ç‰¹æ®Šå¤„ç† ========== */
        @media screen and (min-width: 768px) and (max-width: 1366px) and (orientation: landscape) and (hover: none) and (pointer: coarse) {
            #main-title {
                font-size: 2.5rem;
                top: 15px;
            }

            #ui-container {
                top: 70px;
                left: 15px;
            }

            .instructions {
                font-size: 0.85rem;
                padding: 15px;
                line-height: 1.6;
            }

            .desktop-only {
                display: none !important;
            }
            .mobile-only {
                display: inline;
            }

            .btn-group {
                left: 15px;
                gap: 15px;
            }

            .magic-btn {
                width: 180px;
                padding: 12px 0;
                font-size: 1rem;
            }

            #cam-container {
                width: 200px;
                height: 150px;
                bottom: 15px;
                right: 15px;
            }
        }
    </style>

    <!-- NOTE: ä¸ºäº†åœ¨ä¸­å›½æ—  VPN ä¹Ÿèƒ½è¿è¡Œï¼Œè¯·å°†ä»¥ä¸‹ mediapipe ç›¸å…³ js æ–‡ä»¶ä¸‹è½½åˆ°æœ¬åœ°ç›®å½• ./libs/mediapipe/ ä¸‹ -->
    <!-- å¯¹åº”ä¸‹è½½æºï¼ˆä»…ä¾›å‚è€ƒï¼‰ï¼šhttps://cdn.jsdelivr.net/npm/@mediapipe/... -->
    <!-- ä¾‹å¦‚ï¼šcamera_utils.js -> ./libs/mediapipe/camera_utils.js -->
    <script src="./libs/mediapipe/camera_utils.js"></script>
    <script src="./libs/mediapipe/control_utils.js"></script>
    <script src="./libs/mediapipe/drawing_utils.js"></script>
    <script src="./libs/mediapipe/hands.js"></script>
</head>
<body>

<!-- ä¿®æ”¹ï¼šæ ‡é¢˜å•ç‹¬æ”¾ç½®ï¼Œå®ç°å±å¹•å±…ä¸­ -->
<h1 id="main-title">Christmas Galaxy</h1>

<div id="ui-container">
    <!-- æ ‡é¢˜å·²ç§»å‡ºï¼Œæ­¤å¤„ä¿ç•™è¯´æ˜ä¹¦ -->
    <div class="instructions">
        ğŸ‘‹ <span class="key-point">Swipe</span>: è½¬åŠ¨<br>
        ğŸ–ï¸ <span class="key-point">Open</span>: çˆ†ç‚¸<br>
        âœŠ <span class="key-point">Fist</span>: åœ£è¯æ ‘<br>
        â˜ï¸ <span class="key-point">Point</span>: æ–‡å­—æ¨¡å¼</b><br>
        ğŸ¤ <span class="key-point">Pinch</span>: å›¾ç‰‡æ”¾å¤§<br>
        âœŒï¸ <span class="key-point">Victory</span>: æ¢é¢œè‰²<br>
        <br>
        <span class="desktop-only"><span class="fs-point">F</span>: å…¨å±ï¼ˆæ¡Œé¢ç«¯ï¼‰</span>
        <span class="mobile-only"><span class="fs-point">åŒå‡»</span>: å…¨å±ï¼ˆæ‰‹æœº / å¹³æ¿ï¼‰</span>
    </div>
    <div id="music-status-display" title="Click to Toggle">ğŸµ Music: Waiting...</div>
</div>

<!-- æŒ‰é’®ç»„ï¼šä½äºå±å¹•å·¦ä¾§ -->
<div class="btn-group">
    <label for="file-input-photo" class="magic-btn secondary">ğŸ“‚ é€‰æ‹©ç…§ç‰‡</label>
    <!-- ç§»åŠ¨ç«¯ï¼šä½¿ç”¨æ ‡å‡†å›¾ç‰‡é€‰æ‹©ï¼Œä¸ä½¿ç”¨æ–‡ä»¶å¤¹é€‰æ‹© -->
    <input type="file" id="file-input-photo" multiple accept="image/*">

    <button id="start-btn" class="magic-btn">ğŸ“¸ å¼€å§‹</button>
</div>

<div id="cam-container">
    <!-- æ³¨æ„ï¼šplaysinline / muted / autoplay å¯¹ iOS å¿…é¡» -->
    <video id="webcam_video" playsinline autoplay muted></video>
    <canvas id="output_canvas"></canvas>
    <div id="gesture-status">System Ready</div>
</div>

<audio id="bg-music" preload="auto"></audio>

<!-- three.js æ”¹ä¸ºæœ¬åœ°æ¨¡å—ï¼š
     è¯·ä¸‹è½½ three@0.160.0 çš„æ„å»ºæ–‡ä»¶åˆ° ./libs/three/ ç›®å½•ï¼Œä¾‹å¦‚ï¼š
     - ./libs/three/build/three.module.js
     - ./libs/three/examples/jsm/*
     ç„¶åä½¿ç”¨ä¸‹é¢çš„æœ¬åœ° importmapã€‚ -->
<script type="importmap">
        {
            "imports": {
                "three": "./libs/three/build/three.module.js",
                "three/addons/": "./libs/three/examples/jsm/"
            }
        }
    </script>

<script type="module">
    import * as THREE from './libs/three/build/three.module.js';
    import { OrbitControls } from './libs/three/examples/jsm/controls/OrbitControls.js';
    import { RoomEnvironment } from './libs/three/examples/jsm/environments/RoomEnvironment.js';
    import { FontLoader } from './libs/three/examples/jsm/loaders/FontLoader.js';
    import { TextGeometry } from './libs/three/examples/jsm/geometries/TextGeometry.js';
    import { MeshSurfaceSampler } from './libs/three/examples/jsm/math/MeshSurfaceSampler.js';

    // --- æ”¹è¿›çš„è®¾å¤‡æ£€æµ‹å‡½æ•° ---
    function detectDeviceType() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const orientation = width > height ? 'landscape' : 'portrait';

        // æ£€æµ‹iPad
        const isIPad = /iPad/.test(navigator.userAgent) ||
            (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) ||
            /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

        // æ£€æµ‹è§¦æ‘¸è®¾å¤‡
        const hasTouch = 'ontouchstart' in window ||
            navigator.maxTouchPoints > 0 ||
            navigator.msMaxTouchPoints > 0;

        // æ£€æµ‹æ˜¯å¦ä¸ºå°å±å¹•æ‰‹æœº
        const isSmallPhone = width <= 480;

        // æ£€æµ‹æ˜¯å¦ä¸ºå¹³æ¿ï¼ˆåŒ…æ‹¬iPadæ¨ªå±ï¼‰
        const isTabletBySize = (width >= 768 && width <= 1366) ||
            (height >= 768 && height <= 1366);

        // æ£€æµ‹æ˜¯å¦ä¸ºå¹³æ¿è®¾å¤‡
        const isTabletDevice = isIPad || (hasTouch && isTabletBySize && !isSmallPhone);

        // æ£€æµ‹æ˜¯å¦ä¸ºæ‰‹æœº
        const isMobilePhone = width <= 767 && hasTouch && !isTabletDevice;

        // æ£€æµ‹æ˜¯å¦ä¸ºæ¡Œé¢ç«¯
        const isDesktop = !hasTouch || (width > 1024 && !isTabletDevice);

        return {
            isMobile: isMobilePhone,
            isTablet: isTabletDevice,
            isDesktop: isDesktop,
            isIPad: isIPad,
            isLandscape: orientation === 'landscape',
            hasTouch: hasTouch,
            width: width,
            height: height
        };
    }

    // --- å…¨å±€å˜é‡ ---
    let loadedFont = null;
    let textMeshes = [];
    let textPoints = [];

    // --- 0. éŸ³ä¹ç³»ç»Ÿ ---
    const PLAYLIST = [
        { title: "We Wish You a Merry Christmas", src: "music/we_wish_you_a_merry_christmas.mp3" },
        { title: "Christmas List", src: "music/christmas_list.mp3" },
        { title: "Jingle Bells", src: "music/jingle_bells.mp3" },
        { title: "Deck the Halls", src: "music/deck_the_halls.mp3" },
        { title: "Silent Night", src: "music/silent_night.mp3" }
    ];

    let currentSongIndex = 0;
    const audioEl = document.getElementById('bg-music');
    const musicDisplay = document.getElementById('music-status-display');

    window.addEventListener('keydown', (e) => {
        if (e.code === 'KeyF') toggleFullscreen();
    });

    // æ ‡è®°ï¼šå½“æµè§ˆå™¨ä¸æ”¯æŒåŸç”Ÿå…¨å±ï¼ˆå¦‚éƒ¨åˆ† iOS æµè§ˆå™¨ï¼‰æ—¶ï¼Œä½¿ç”¨"ä¼ªå…¨å±"æ¨¡å¼ï¼Œä»…éšè— UI
    let isPseudoFullscreen = false;

    function toggleFullscreen() {
        const docEl = document.documentElement;
        const canNativeFullscreen =
            docEl.requestFullscreen ||
            docEl.webkitRequestFullscreen ||
            docEl.mozRequestFullScreen ||
            docEl.msRequestFullscreen;

        const isNativeFullscreen =
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement;

        if (canNativeFullscreen) {
            // ä¼˜å…ˆå°è¯•åŸç”Ÿå…¨å±ï¼ˆæ¡Œé¢ / éƒ¨åˆ†å®‰å“æµè§ˆå™¨ï¼‰
            if (!isNativeFullscreen) {
                if (docEl.requestFullscreen) {
                    docEl.requestFullscreen().catch(e => console.log(e));
                } else if (docEl.webkitRequestFullscreen) {
                    docEl.webkitRequestFullscreen();
                } else if (docEl.mozRequestFullScreen) {
                    docEl.mozRequestFullScreen();
                } else if (docEl.msRequestFullscreen) {
                    docEl.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        } else {
            // iOS ç­‰ä¸æ”¯æŒ Fullscreen API çš„æµè§ˆå™¨ï¼šä½¿ç”¨"ä¼ªå…¨å±"ï¼Œé€šè¿‡éšè— UI è¥é€ æ²‰æµ¸æ•ˆæœ
            isPseudoFullscreen = !isPseudoFullscreen;
            document.body.classList.toggle('ui-hidden', isPseudoFullscreen);
            // å°½é‡æ»šåŠ¨åˆ°é¡¶éƒ¨ï¼Œå‡å°‘æµè§ˆå™¨åœ°å€æ å¹²æ‰°
            window.scrollTo(0, 0);
        }
    }

    document.addEventListener('fullscreenchange', () => {
        const isNativeFullscreen =
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement;
        document.body.classList.toggle('ui-hidden', !!isNativeFullscreen || isPseudoFullscreen);
        if (!isNativeFullscreen) {
            // åŸç”Ÿå…¨å±é€€å‡ºæ—¶ï¼Œé‡ç½®ä¼ªå…¨å±æ ‡è®°
            isPseudoFullscreen = false;
        }
    });

    musicDisplay.addEventListener('click', () => {
        if (audioEl.paused) {
            if (audioEl.src) audioEl.play().catch(e => console.warn(e));
            else playMusic(currentSongIndex);
        } else nextSong();
    });

    audioEl.addEventListener('error', () => {
        musicDisplay.innerText = "âŒ Network Error (Skip in 2s)";
        musicDisplay.style.color = 'orange';
        setTimeout(() => nextSong(), 2000);
    });

    audioEl.addEventListener('ended', nextSong);

    function playMusic(index) {
        currentSongIndex = (index + PLAYLIST.length) % PLAYLIST.length;
        const song = PLAYLIST[currentSongIndex];
        musicDisplay.style.display = 'block';
        musicDisplay.innerText = `âŒ› Buffering: ${song.title}...`;
        musicDisplay.style.color = '#00d2ff';
        audioEl.src = song.src;
        audioEl.volume = 1.0;
        audioEl.play().then(() => {
            musicDisplay.innerText = `ğŸµ Playing: ${song.title}`;
            musicDisplay.style.color = '#00ff00';
        }).catch(() => {
            musicDisplay.innerText = `âš ï¸ Click Here to Enable Audio`;
            musicDisplay.style.color = 'yellow';
        });
    }
    function nextSong() { playMusic(currentSongIndex + 1); }

    // --- 1. åœºæ™¯é…ç½® ---
    // ========== æ€§èƒ½ä¼˜åŒ–ï¼šå¤§å¹…å‡å°‘ç²’å­æ•°é‡ ==========
    const CONFIG = {
        count: 3500,  // ä»6000å‡å°‘åˆ°2000
        radius: 8,
        height: 25,
        // æé«˜æ¨¡å¼åˆ‡æ¢æ—¶çš„æ¢å¤é€Ÿåº¦ï¼Œè®© TREE/TEXT/CLOUD ä¹‹é—´è¿‡æ¸¡æ›´è¿…é€Ÿ
        restoreSpeed: 0.3,
        floatSpeed: 0.3
    };

    const PALETTES = [
        { name: "Classic Gold/Red", gold: 0xFFD700, red: 0xD41E3A, green: 0x005235 },
        { name: "Frozen Silver/Blue", gold: 0xE0FFFF, red: 0x4682B4, green: 0x708090 },
        { name: "Candy Pop", gold: 0xFF69B4, red: 0x00FFFF, green: 0x9370DB }
    ];
    let currentPaletteIndex = 0;
    let currentBorderColor = new THREE.Color(PALETTES[0].gold);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050510, 0.010);

    // ä½¿ç”¨æ”¹è¿›çš„è®¾å¤‡æ£€æµ‹
    const deviceInfo = detectDeviceType();
    const isMobile = deviceInfo.isMobile;
    const isTablet = deviceInfo.isTablet;
    const isLandscape = deviceInfo.isLandscape;
    const isIPad = deviceInfo.isIPad;

    // æ ¹æ®è®¾å¤‡è°ƒæ•´ç›¸æœºå‚æ•°
    let cameraFOV = 45;
    let cameraZ = 55;
    let cameraY = 5;

    if (isMobile) {
        if (isLandscape) {
            cameraFOV = 60;
            cameraZ = 45;
            cameraY = 3;
        } else {
            cameraFOV = 55;
            cameraZ = 50;
            cameraY = 4;
        }
    } else if (isTablet) {
        // iPadæ¨ªå±ç‰¹æ®Šå¤„ç†
        if (isIPad && isLandscape) {
            cameraFOV = 52;
            cameraZ = 48;
            cameraY = 4;
        } else {
            cameraFOV = 50;
            cameraZ = 52;
            cameraY = 4.5;
        }
    }

    const camera = new THREE.PerspectiveCamera(cameraFOV, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, cameraY, cameraZ);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.body.appendChild(renderer.domElement);

    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const mainLight = new THREE.DirectionalLight(0xffeeb1, 2.0);
    mainLight.position.set(0, 50, 20);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 1024;  // å‡å°‘é˜´å½±è´´å›¾å¤§å°
    mainLight.shadow.mapSize.height = 1024; // å‡å°‘é˜´å½±è´´å›¾å¤§å°
    scene.add(mainLight);

    // æ³¨å†ŒService Worker
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/service-worker.js')
                .then((registration) => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                })
                .catch((error) => {
                    console.log('ServiceWorker registration failed: ', error);
                });
        });
    }
    camera.add(new THREE.PointLight(0xffffff, 0.8));
    scene.add(camera);

    // --- è£…é¥° (Decorations) ---
    const decorGroup = new THREE.Group();
    scene.add(decorGroup);

    // ========== æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘èºæ—‹è£…é¥°ç²’å­æ•°é‡ ==========
    const spiralGeo = new THREE.BufferGeometry();
    const spiralCount = 200;  // ä»600å‡å°‘åˆ°200
    const spiralPos = new Float32Array(spiralCount * 3);
    for(let i=0; i<spiralCount; i++) {
        spiralPos[i*3] = 0; spiralPos[i*3+1] = 0; spiralPos[i*3+2] = 0;
    }
    spiralGeo.setAttribute('position', new THREE.BufferAttribute(spiralPos, 3));
    const spiralMat = new THREE.PointsMaterial({
        color: 0xffaa00, size: 0.4, transparent: true, opacity: 0.6,
        blending: THREE.AdditiveBlending
    });
    const spiralSystem = new THREE.Points(spiralGeo, spiralMat);
    decorGroup.add(spiralSystem);

    const ringGeo = new THREE.RingGeometry(8, 9, 32);  // å‡å°‘é¡¶ç‚¹æ•°
    const ringMat = new THREE.MeshBasicMaterial({ color: 0xffd700, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
    const floorRing = new THREE.Mesh(ringGeo, ringMat);
    floorRing.rotation.x = -Math.PI / 2;
    floorRing.position.y = -CONFIG.height / 2 - 2;
    decorGroup.add(floorRing);


    // --- 2. ç²’å­ä¸å¯¹è±¡ ---
    // ========== æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘å‡ ä½•ä½“ç»†èŠ‚ ==========
    const sphereMaterial = new THREE.MeshStandardMaterial({ metalness: 0.8, roughness: 0.2 });
    const cubeMaterial = new THREE.MeshStandardMaterial({ metalness: 0.7, roughness: 0.4 });
    const sphereMesh = new THREE.InstancedMesh(new THREE.SphereGeometry(0.35, 8, 6), sphereMaterial, CONFIG.count);  // å‡å°‘å‡ ä½•ä½“ç»†èŠ‚
    const cubeMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), cubeMaterial, CONFIG.count);
    sphereMesh.castShadow = true; sphereMesh.receiveShadow = true;
    cubeMesh.castShadow = true; cubeMesh.receiveShadow = true;

    const treeGroup = new THREE.Group();
    treeGroup.add(sphereMesh);
    treeGroup.add(cubeMesh);
    scene.add(treeGroup);

    const topperMat = new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xffaa00, emissiveIntensity: 1 });
    const topperMesh = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), topperMat);
    treeGroup.add(topperMesh);

    // æ˜Ÿçš„è¿åŠ¨çŠ¶æ€
    // posText å°†åœ¨åˆ‡æ¢åˆ°æ–‡å­—æ¨¡å¼æ—¶æ ¹æ®æ–‡å­—é…ç½®åŠ¨æ€è®¡ç®—
    const topperState = {
        posTree: new THREE.Vector3(0, CONFIG.height/2+1.5, 0),
        posCloud: new THREE.Vector3(0, 20, 0),
        posText: new THREE.Vector3(0, 8, 0),   // åˆå§‹å€¼ï¼Œå°†åœ¨æ–‡å­—æ¨¡å¼ä¸‹åŠ¨æ€æ›´æ–°
        currentPos: new THREE.Vector3(0, CONFIG.height/2+1.5, 0),
        targetPos: new THREE.Vector3(0, CONFIG.height/2+1.5, 0),
        floatOffset: 0
    };

    // --- NEW: ç¤¼ç‰©ç›’ç»„ï¼ˆåœ£è¯æ ‘è„šä¸‹çš„å°ç¤¼ç‰©ï¼‰ ---
    const giftGroup = new THREE.Group();
    scene.add(giftGroup);
    const gifts = [];

    function createGifts() {
        // ç¤¼ç‰©ç›’å›´ç»•æ ‘åº•éƒ¨ä¸€åœˆæ‘†æ”¾
        const baseY = -CONFIG.height / 2 - 1.2;
        const innerR = CONFIG.radius * 0.9;
        const outerR = CONFIG.radius * 1.35;
        const giftCount = 8;  // ä»10å‡å°‘åˆ°8

        for (let i = 0; i < giftCount; i++) {
            const angle = (i / giftCount) * Math.PI * 2 + Math.random() * 0.5;
            const r = THREE.MathUtils.lerp(innerR, outerR, Math.random());
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;

            const w = THREE.MathUtils.randFloat(1.0, 1.8);
            const h = THREE.MathUtils.randFloat(0.8, 1.6);
            const d = THREE.MathUtils.randFloat(1.0, 1.8);

            const boxGeo = new THREE.BoxGeometry(w, h, d);
            // åˆå§‹é¢œè‰²ä½¿ç”¨å½“å‰è°ƒè‰²æ¿ä¸­çš„ç»¿è‰²ï¼Œåç»­ç”± applyColors ç»Ÿä¸€æ›´æ–°
            const boxMat = new THREE.MeshStandardMaterial({
                color: PALETTES[0].green,
                roughness: 0.65,
                metalness: 0.25
            });
            const boxMesh = new THREE.Mesh(boxGeo, boxMat);
            boxMesh.castShadow = true;
            boxMesh.receiveShadow = true;

            const ribbonThickness = Math.min(w, d) * 0.18;
            const ribbonHeight = h * 1.02;
            const ribbonGeo1 = new THREE.BoxGeometry(ribbonThickness, ribbonHeight, d * 1.06);
            const ribbonGeo2 = new THREE.BoxGeometry(w * 1.06, ribbonHeight, ribbonThickness);
            const ribbonMat = new THREE.MeshStandardMaterial({
                color: PALETTES[0].gold,
                roughness: 0.4,
                metalness: 0.7,
                emissive: 0x222222,
                emissiveIntensity: 0.35
            });

            const ribbon1 = new THREE.Mesh(ribbonGeo1, ribbonMat);
            const ribbon2 = new THREE.Mesh(ribbonGeo2, ribbonMat);
            ribbon1.position.y = 0;
            ribbon2.position.y = 0;
            boxMesh.add(ribbon1);
            boxMesh.add(ribbon2);

            boxMesh.position.set(x, baseY + h / 2, z);
            boxMesh.rotation.y = Math.random() * Math.PI * 2;

            giftGroup.add(boxMesh);

            const treePos = boxMesh.position.clone();
            const cloudPos = getSafeZonePos();

            gifts.push({
                mesh: boxMesh,
                boxMaterial: boxMat,
                ribbonMaterial: ribbonMat,
                posTree: treePos,
                posCloud: cloudPos,
                currentPos: treePos.clone(),
                targetPos: treePos.clone(),
                baseY: boxMesh.position.y,
                wobblePhase: Math.random() * Math.PI * 2
            });
        }
    }
    createGifts();

    const instances = [];
    const photoInstances = [];
    const dummy = new THREE.Object3D();
    const _color = new THREE.Color();

    function getTreePos(i, total) {
        const ratio = i / total;
        const y = ratio * CONFIG.height - CONFIG.height/2;
        const r = Math.pow((1-ratio), 0.9) * CONFIG.radius;
        const angle = i * 137.5;
        const rad = Math.sqrt(Math.random()) * r;
        return new THREE.Vector3(Math.cos(angle)*rad, y, Math.sin(angle)*rad);
    }

    function getCloudPos() {
        return new THREE.Vector3(
            (Math.random() - 0.5) * 150,  // å‡å°‘äº‘æ¨¡å¼çš„èŒƒå›´
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 80
        );
    }

    function getSafeZonePos() {
        return new THREE.Vector3(
            (Math.random() - 0.5) * 40,  // å‡å°‘èŒƒå›´
            (Math.random() - 0.5) * 25,
            (Math.random() - 0.5) * 15
        );
    }

    // ====================================================
    // --- NEW: è¶…æ—¶ç©ºæ˜Ÿå°˜é£æš´ (Hyper Cosmic Storm) ---
    // ====================================================

    // 1. ç”ŸæˆæŸ”å’Œå…‰ç‚¹æè´¨
    const glowCanvas = document.createElement('canvas');
    glowCanvas.width = 32; glowCanvas.height = 32;
    const ctx = glowCanvas.getContext('2d');
    const grd = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    grd.addColorStop(0, 'rgba(255, 255, 255, 1)');
    grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = grd; ctx.fillRect(0, 0, 32, 32);
    const glowTex = new THREE.CanvasTexture(glowCanvas);

    // 2. æ˜Ÿå°˜ç³»ç»Ÿ (å…¨å±è¦†ç›–)
    // ========== æ€§èƒ½ä¼˜åŒ–ï¼šå¤§å¹…å‡å°‘æ˜Ÿå°˜ç²’å­æ•°é‡ ==========
    const galaxyGeo = new THREE.BufferGeometry();
    const galaxyCount = 1000;  // ä»3000å‡å°‘åˆ°1000
    const galaxyPos = new Float32Array(galaxyCount * 3);
    const galaxySizes = new Float32Array(galaxyCount);

    for(let i=0; i<galaxyCount; i++) {
        // åœ¨å·¨å¤§çš„çƒä½“å†…éšæœºåˆ†å¸ƒ (Radius 150)
        const r = Math.random() * 120;  // å‡å°‘åŠå¾„
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        galaxyPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
        galaxyPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
        galaxyPos[i*3+2] = r * Math.cos(phi);

        // éšæœºå¤§å°ï¼Œåˆ¶é€ æ™¯æ·±æ„Ÿ
        galaxySizes[i] = Math.random() * 1.5 + 0.5;
    }
    galaxyGeo.setAttribute('position', new THREE.BufferAttribute(galaxyPos, 3));
    galaxyGeo.setAttribute('size', new THREE.BufferAttribute(galaxySizes, 1));

    const galaxyMat = new THREE.PointsMaterial({
        color: 0xffcc00,
        size: 1.0,
        map: glowTex,
        transparent: true, opacity: 0,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });
    const galaxySystem = new THREE.Points(galaxyGeo, galaxyMat);
    scene.add(galaxySystem);

    // 3. æµæ˜Ÿé›¨ (Shooting Lines) - å¢åŠ é€Ÿåº¦æ„Ÿ
    // ========== æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘æµæ˜Ÿæ•°é‡ ==========
    const lineGeo = new THREE.BufferGeometry();
    const lineCount = 60;  // ä»150å‡å°‘åˆ°60
    const linePos = [];
    const lineSpeed = [];

    for(let i=0; i<lineCount; i++) {
        // éšæœºèµ·ç‚¹
        const x = (Math.random()-0.5) * 250;  // å‡å°‘èŒƒå›´
        const y = (Math.random()-0.5) * 250;
        const z = (Math.random()-0.5) * 250;
        // æ¯æ¡çº¿ä¸¤ä¸ªç‚¹
        linePos.push(x, y, z);
        linePos.push(x, y - 5, z); // å°¾å·´é•¿åº¦
        lineSpeed.push((Math.random() + 0.5) * 2);
    }
    lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
    const lineMat = new THREE.LineBasicMaterial({
        color: 0xffffff, transparent: true, opacity: 0, blending: THREE.AdditiveBlending
    });
    const shootingLines = new THREE.LineSegments(lineGeo, lineMat);
    scene.add(shootingLines);


    // --- 4. é›ªèŠ±ç³»ç»Ÿ ---
    // ========== æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘é›ªèŠ±æ•°é‡ ==========
    const snowGeo = new THREE.BufferGeometry();
    const snowCount = 800;  // ä»1500å‡å°‘åˆ°800
    const snowPos = new Float32Array(snowCount * 3);
    const snowVel = [];
    for(let i=0; i<snowCount; i++) {
        snowPos[i*3] = (Math.random()-0.5) * 80;   // å‡å°‘èŒƒå›´
        snowPos[i*3+1] = (Math.random()-0.5) * 50;
        snowPos[i*3+2] = (Math.random()-0.5) * 40 + 20;
        snowVel.push({
            x: (Math.random()-0.5)*0.05,
            y: -(Math.random()*0.1 + 0.05),
            z: (Math.random()-0.5)*0.05
        });
    }
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
    // ä½¿ç”¨æœ¬åœ°ç”Ÿæˆçš„é›ªèŠ±çº¹ç†
    function createSnowTexture() {
        // ç®€åŒ–çº¹ç†ï¼Œæé«˜æ€§èƒ½
        const c = document.createElement('canvas');
        c.width = c.height = 64;  // é™ä½åˆ†è¾¨ç‡
        const ctx = c.getContext('2d');
        const cx = c.width / 2;
        const cy = c.height / 2;
        const radius = 13;

        ctx.clearRect(0, 0, c.width, c.height);
        ctx.save();
        ctx.translate(cx, cy);

        // ç®€å•çš„å¾„å‘æ¸å˜
        const g = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 1.2);
        g.addColorStop(0, 'rgba(255,255,255,0.95)');
        g.addColorStop(0.45, 'rgba(255,255,255,0.65)');
        g.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(0, 0, radius * 1.2, 0, Math.PI * 2);
        ctx.fill();

        // ç®€åŒ–çš„é›ªèŠ±å½¢çŠ¶ï¼ˆåªç”»ç®€å•çš„åå­—ï¼‰
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';

        // ç®€å•çš„åå­—å½¢
        ctx.beginPath();
        ctx.moveTo(0, -radius);
        ctx.lineTo(0, radius);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(-radius, 0);
        ctx.lineTo(radius, 0);
        ctx.stroke();

        ctx.restore();

        const tex = new THREE.CanvasTexture(c);
        tex.anisotropy = 2;  // å‡å°‘å„å‘å¼‚æ€§
        tex.needsUpdate = true;
        return tex;
    }
    const snowTexture = createSnowTexture();
    const snowMat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.7,
        map: snowTexture,
        transparent: true,
        opacity: 0,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });
    const snowSystem = new THREE.Points(snowGeo, snowMat);
    scene.add(snowSystem);

    // --- 4b. æ–‡å­—æ¨¡å¼ä¸“å±é£˜é›ªï¼ˆæ›´å¤§ã€æ›´è¿‘ï¼Œåˆ‡æ¢ TEXT æ—¶æ·¡å…¥ï¼‰ ---
    // ========== æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘æ–‡å­—æ¨¡å¼é›ªèŠ±æ•°é‡ ==========
    const textSnowGeo = new THREE.BufferGeometry();
    const textSnowCount = 600;  // ä»1200å‡å°‘åˆ°600
    const textSnowPos = new Float32Array(textSnowCount * 3);
    const textSnowVel = [];
    for (let i = 0; i < textSnowCount; i++) {
        textSnowPos[i*3]   = (Math.random()-0.5) * 60;   // å‡å°‘èŒƒå›´
        textSnowPos[i*3+1] = 20 + Math.random() * 40;
        textSnowPos[i*3+2] = (Math.random()-0.5) * 35;
        textSnowVel.push({
            x: (Math.random()-0.5) * 0.08,
            y: -(Math.random()*0.25 + 0.06),
            z: (Math.random()-0.5) * 0.06
        });
    }
    textSnowGeo.setAttribute('position', new THREE.BufferAttribute(textSnowPos, 3));
    const textSnowMat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1.5,  // ç¨å¾®å‡å°å¤§å°
        map: snowTexture,
        transparent: true,
        opacity: 0,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });
    const textSnowSystem = new THREE.Points(textSnowGeo, textSnowMat);
    scene.add(textSnowSystem);

    // --- 5. æ–‡å­—ç”Ÿæˆé€»è¾‘ ---
    const fontLoader = new FontLoader();

    // æ ¹æ®å±å¹•å®½åº¦è‡ªåŠ¨é€‚é…æ–‡å­—å¤§å°å’Œä½ç½® - ä¿®å¤æ‰€æœ‰è®¾å¤‡æ˜¾ç¤ºé—®é¢˜
    function getTextConfig() {
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const isPortrait = screenHeight > screenWidth;
        const aspectRatio = screenWidth / screenHeight;

        // æ£€æŸ¥è®¾å¤‡ç±»å‹
        const deviceInfo = detectDeviceType();
        const isIPad = deviceInfo.isIPad;
        const isMobile = deviceInfo.isMobile;
        const isTablet = deviceInfo.isTablet;
        const isIPadPortrait = isIPad && isPortrait;

        // iPhoneç‰¹æ®Šå¤„ç†
        const isiPhone = /iPhone/.test(navigator.userAgent) && !window.MSStream;
        const isiPhonePortrait = isiPhone && isPortrait;

        // ç¡®å®šè¾¹è·è¦æ±‚ï¼ˆåƒç´ å€¼ï¼Œç”¨äºè®¡ç®—å¯ç”¨å®½åº¦ï¼‰
        let marginPx;

        if (isiPhonePortrait) {
            marginPx = 40; // iPhoneç«–å±å‡å°‘è¾¹è·
        } else if (isIPadPortrait) {
            marginPx = 80;
        } else if (isMobile) {
            marginPx = 20;
        } else if (isTablet) {
            marginPx = 40;
        } else {
            marginPx = 50;
        }

        // åŸºç¡€å°ºå¯¸è®¡ç®— - ä¼˜å…ˆä¿è¯æ–‡å­—åœ¨å±å¹•ä¸Šå¯è§
        let baseSize;

        if (isiPhonePortrait) {
            // iPhoneç«–å±ï¼šç¡®ä¿æ–‡å­—è¶³å¤Ÿå¤§
            if (screenWidth <= 375) { // iPhone 6/7/8/X/11 Pro/12 mini/13 mini
                baseSize = 2.8;
            } else if (screenWidth <= 414) { // iPhone 6+/7+/8+/XR/11/12/13
                baseSize = 3.0;
            } else if (screenWidth <= 428) { // iPhone 12 Pro Max/13 Pro Max/14 Plus
                baseSize = 3.2;
            } else {
                baseSize = 3.4;
            }
        } else if (isIPadPortrait) {
            if (screenWidth <= 768) {
                baseSize = 2.0;
            } else {
                baseSize = 2.2;
            }
        } else if (screenWidth <= 320) {
            baseSize = 2.5;
        } else if (screenWidth <= 375) {
            baseSize = 2.8;
        } else if (screenWidth <= 414) {
            baseSize = 3.0;
        } else if (screenWidth <= 480) {
            baseSize = 3.2;
        } else if (screenWidth <= 768) {
            baseSize = 3.5;
        } else if (screenWidth <= 1024) {
            baseSize = 3.8;
        } else if (screenWidth <= 1366) {
            baseSize = 4.0;
        } else {
            baseSize = 4.2;
        }

        // æ ¹æ®çºµæ¨ªæ¯”è°ƒæ•´
        let size = baseSize;

        if (aspectRatio < 0.6) { // éå¸¸é«˜çš„ç«–å±
            size *= 0.85;
        } else if (aspectRatio < 0.75) {
            size *= 0.9;
        } else if (aspectRatio < 1.0) {
            size *= 0.95;
        } else if (aspectRatio > 1.5) { // éå¸¸å®½çš„æ¨ªå±
            size *= 1.1;
        } else if (aspectRatio > 2.0) {
            size *= 1.2;
        }

        // iPhoneç«–å±ç‰¹æ®Šè°ƒæ•´
        if (isiPhonePortrait) {
            size *= 1.1; // å¢åŠ 10%å¤§å°
        }

        // ç¡®ä¿æœ€å°å’Œæœ€å¤§å°ºå¯¸
        size = Math.max(2.5, Math.min(4.5, size));

        // æ ¹æ®å±å¹•å®½åº¦åŠ¨æ€è®¡ç®—å­—æ¯é—´è·
        let letterSpacing;
        if (isiPhonePortrait) {
            letterSpacing = 0.08;
        } else if (isIPadPortrait) {
            letterSpacing = 0.05;
        } else if (screenWidth <= 480) {
            letterSpacing = 0.08 + (screenWidth - 320) / 160 * 0.04;
        } else if (screenWidth <= 768) {
            letterSpacing = 0.12 + (screenWidth - 480) / 288 * 0.02;
        } else if (screenWidth <= 1024) {
            letterSpacing = 0.14 + (screenWidth - 768) / 256 * 0.02;
        } else {
            letterSpacing = 0.16 + Math.min((screenWidth - 1024) / 1920 * 0.03, 0.03);
        }

        // æ ¹æ®çºµæ¨ªæ¯”è°ƒæ•´å­—æ¯é—´è·
        if (aspectRatio < 0.75) {
            letterSpacing *= 0.6;
        }

        // æœ€ç»ˆé™åˆ¶å­—æ¯é—´è·èŒƒå›´
        letterSpacing = Math.max(0.03, Math.min(0.2, letterSpacing));

        // æ ¹æ®å­—æ¯å¤§å°å’Œå±å¹•é«˜åº¦è®¡ç®—å‚ç›´ä½ç½®
        let y1, y2;
        if (isiPhonePortrait) {
            y1 = size * 0.8;
            y2 = -size * 0.8;
        } else if (isIPadPortrait) {
            y1 = size * 0.7;
            y2 = -size * 0.7;
        } else {
            y1 = size * 0.6;
            y2 = -size * 0.6;
        }

        // æ ¹æ®å­—æ¯å¤§å°è®¡ç®—åšåº¦
        const spacing = size * 0.04;

        return {
            size: size,
            y1: y1,
            y2: y2,
            spacing: spacing,
            letterSpacing: letterSpacing,
            marginPx: marginPx,
            isIPadPortrait: isIPadPortrait,
            isiPhonePortrait: isiPhonePortrait,
            aspectRatio: aspectRatio,
            screenWidth: screenWidth,
            screenHeight: screenHeight
        };
    }

    // ç²¾ç¡®çš„å­—æ¯é—´è·å‡½æ•°ï¼šåˆ†åˆ«åˆ›å»ºæ¯ä¸ªå­—æ¯å¹¶æ‰‹åŠ¨è°ƒæ•´ä½ç½®ï¼Œæ”¯æŒç²¾ç»†å¾®è°ƒ
    function createTextWithLetterSpacing(font, text, size, height, letterSpacing) {
        const letters = text.split('');
        const letterGeometries = [];
        let currentX = 0;

        // ä¸ºæ¯ä¸ªå­—æ¯åˆ›å»ºå‡ ä½•ä½“å¹¶è®¡ç®—ä½ç½®
        letters.forEach((letter) => {
            const letterGeo = new TextGeometry(letter, {
                font: font,
                size: size,
                height: height,
                curveSegments: 4,  // å‡å°‘æ›²çº¿æ®µæ•°
                bevelEnabled: false
            });

            // è®¡ç®—å­—æ¯çš„è¾¹ç•Œæ¡†
            letterGeo.computeBoundingBox();
            const box = letterGeo.boundingBox;
            const letterWidth = box.max.x - box.min.x;

            // å°†å­—æ¯å‡ ä½•ä½“ç§»åŠ¨åˆ°æ­£ç¡®ä½ç½®
            const offsetX = currentX - box.min.x;
            letterGeo.translate(offsetX, 0, 0);

            letterGeometries.push(letterGeo);

            // æ›´æ–°ä¸‹ä¸€ä¸ªå­—æ¯çš„èµ·å§‹ä½ç½®
            currentX += letterWidth + (letterSpacing * size * 2);
        });

        // åˆå¹¶æ‰€æœ‰å­—æ¯çš„å‡ ä½•ä½“
        const mergedGeo = new THREE.BufferGeometry();
        const mergedPositions = [];
        const mergedNormals = [];
        const mergedUvs = [];
        const mergedIndices = [];
        let vertexOffset = 0;

        letterGeometries.forEach((geo) => {
            const pos = geo.attributes.position;
            const normal = geo.attributes.normal;
            const uv = geo.attributes.uv;
            const index = geo.index;

            // æ·»åŠ é¡¶ç‚¹
            for (let i = 0; i < pos.count; i++) {
                mergedPositions.push(pos.getX(i), pos.getY(i), pos.getZ(i));
                if (normal) {
                    mergedNormals.push(normal.getX(i), normal.getY(i), normal.getZ(i));
                }
                if (uv) {
                    mergedUvs.push(uv.getX(i), uv.getY(i));
                }
            }

            // æ·»åŠ ç´¢å¼•
            if (index) {
                for (let i = 0; i < index.count; i++) {
                    mergedIndices.push(index.getX(i) + vertexOffset);
                }
            }

            vertexOffset += pos.count;
        });

        mergedGeo.setAttribute('position', new THREE.Float32BufferAttribute(mergedPositions, 3));
        if (mergedNormals.length > 0) {
            mergedGeo.setAttribute('normal', new THREE.Float32BufferAttribute(mergedNormals, 3));
        }
        if (mergedUvs.length > 0) {
            mergedGeo.setAttribute('uv', new THREE.Float32BufferAttribute(mergedUvs, 2));
        }
        if (mergedIndices.length > 0) {
            mergedGeo.setIndex(mergedIndices);
        }

        // å±…ä¸­æ•´ä¸ªæ–‡å­—
        mergedGeo.computeBoundingBox();
        const mergedBox = mergedGeo.boundingBox;
        const centerX = (mergedBox.min.x + mergedBox.max.x) / 2;
        mergedGeo.translate(-centerX, 0, 0);

        // æ¸…ç†ä¸´æ—¶å‡ ä½•ä½“
        letterGeometries.forEach(geo => geo.dispose());

        return mergedGeo;
    }

    // åˆ›å»ºæ–‡å­—å‡ ä½•ä½“
    function createTextGeometry() {
        // æ¸…é™¤æ—§çš„æ–‡å­—ç½‘æ ¼
        textMeshes.forEach(mesh => {
            scene.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
        });
        textMeshes = [];
        textPoints = [];

        if (!loadedFont) return;

        const textConfig = getTextConfig();

        // ä½¿ç”¨ç²¾ç¡®çš„å­—æ¯é—´è·å‡½æ•°åˆ›å»ºæ–‡å­—
        const geo1 = createTextWithLetterSpacing(
            loadedFont,
            'MERRY',
            textConfig.size,
            textConfig.spacing,
            textConfig.letterSpacing
        );
        const mesh1 = new THREE.Mesh(geo1, new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
        mesh1.position.y = textConfig.y1;
        mesh1.updateMatrixWorld();
        scene.add(mesh1);
        textMeshes.push(mesh1);

        // ä½¿ç”¨ç²¾ç¡®çš„å­—æ¯é—´è·å‡½æ•°åˆ›å»ºæ–‡å­—
        const geo2 = createTextWithLetterSpacing(
            loadedFont,
            'CHRISTMAS',
            textConfig.size,
            textConfig.spacing,
            textConfig.letterSpacing
        );
        const mesh2 = new THREE.Mesh(geo2, new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 }));
        mesh2.position.y = textConfig.y2;
        mesh2.updateMatrixWorld();
        scene.add(mesh2);
        textMeshes.push(mesh2);

        const sampler1 = new MeshSurfaceSampler(mesh1).build();
        const sampler2 = new MeshSurfaceSampler(mesh2).build();

        const tempPos = new THREE.Vector3();
        const tempTarget = new THREE.Vector3();

        const halfCount = Math.floor(CONFIG.count / 2);
        for (let i = 0; i < CONFIG.count; i++) {
            if (i < halfCount) {
                sampler1.sample(tempPos);
                tempTarget.copy(tempPos).applyMatrix4(mesh1.matrixWorld);
            } else {
                sampler2.sample(tempPos);
                tempTarget.copy(tempPos).applyMatrix4(mesh2.matrixWorld);
            }
            textPoints.push(new THREE.Vector3(tempTarget.x, tempTarget.y, 0));
        }

        // æ›´æ–°å®ä¾‹çš„posText
        instances.forEach((inst, i) => {
            if (textPoints[i]) inst.posText = textPoints[i];
            else inst.posText = inst.posTree;
        });
    }

    // æ›´æ–°æ–‡å­—æ¨¡å¼ä¸‹å®ä¾‹çš„ç›®æ ‡ä½ç½®
    function updateTextModePositions() {
        if (state.mode === 'TEXT') {
            instances.forEach((inst, i) => {
                if (textPoints[i]) inst.targetPos = textPoints[i];
                else inst.targetPos = inst.posTree;
            });
        }
    }

    // å­—ä½“åŠ è½½
    fontLoader.load('./assets/fonts/helvetiker_bold.typeface.json', (font) => {
        loadedFont = font;
        createTextGeometry();
    });

    // --- åˆå§‹åŒ–ç²’å­ ---
    let sIdx=0, cIdx=0;
    for(let i=0; i<CONFIG.count; i++) {
        const isSphere = Math.random()>0.5;
        const mesh = isSphere ? sphereMesh : cubeMesh;
        const idx = isSphere ? sIdx++ : cIdx++;

        const treePos = getTreePos(i, CONFIG.count);
        const cloudPos = getCloudPos();

        instances.push({
            type: isSphere ? 'sphere' : 'cube',
            meshIndex: idx,
            targetPos: treePos,
            posTree: treePos,
            posCloud: cloudPos,
            posText: cloudPos,
            currentPos: treePos.clone(),
            rotSpeed: {x:(Math.random()-0.5)*0.05, y:(Math.random()-0.5)*0.05},
            rotation: new THREE.Euler(Math.random()*6, Math.random()*6, 0)
        });

        dummy.position.copy(treePos);
        dummy.scale.setScalar(0.5 + Math.random());
        dummy.updateMatrix();
        mesh.setMatrixAt(idx, dummy.matrix);
    }

    function applyColors(paletteIdx) {
        const p = PALETTES[paletteIdx];
        currentBorderColor.setHex(p.gold);
        topperMat.color.setHex(p.gold);
        topperMat.emissive.setHex(p.red);

        spiralMat.color.setHex(p.gold);
        floorRing.material.color.setHex(p.gold);

        // æ˜Ÿå°˜é¢œè‰²è”åŠ¨
        galaxyMat.color.setHex(p.gold);
        lineMat.color.setHex(p.gold);

        // ç¤¼ç‰©ç›’é¢œè‰²è”åŠ¨ï¼šç›’å­ä¸»ä½“ç”¨çº¢/ç»¿ï¼Œä¸å¸¦ç”¨é‡‘è‰²
        gifts.forEach((g, idx) => {
            const useRed = (idx % 2 === 0);
            g.boxMaterial.color.setHex(useRed ? p.red : p.green);
            g.ribbonMaterial.color.setHex(p.gold);
            g.boxMaterial.needsUpdate = true;
            g.ribbonMaterial.needsUpdate = true;
        });

        photoInstances.forEach(inst => {
            if(inst.mesh.material) inst.mesh.material.color.setHex(p.gold);
        });

        for(let i=0; i<CONFIG.count; i++) {
            const isSphere = instances[i].type === 'sphere';
            if(isSphere) _color.setHex(Math.random()>0.3 ? p.gold : p.red);
            else _color.setHex(Math.random()>0.5 ? p.gold : p.green);
            const mesh = isSphere ? sphereMesh : cubeMesh;
            mesh.setColorAt(instances[i].meshIndex, _color);
        }
        sphereMesh.instanceColor.needsUpdate = true;
        cubeMesh.instanceColor.needsUpdate = true;
    }
    applyColors(0);

    // --- ç…§ç‰‡å¤„ç† ---
    const photoGroup = new THREE.Group();
    scene.add(photoGroup);
    document.getElementById('file-input-photo').addEventListener('change', handleFileSelect);

    function handleFileSelect(event) {
        const files = Array.from(event.target.files).filter(f => f.type.startsWith('image/'));
        if(files.length === 0) return;
        photoInstances.forEach(p => {
            photoGroup.remove(p.mesh);
            p.mesh.geometry.dispose(); p.mesh.material.dispose();
            if (p.mesh.children[0]) { p.mesh.children[0].geometry.dispose(); p.mesh.children[0].material.dispose(); }
        });
        photoInstances.length = 0;

        const loader = new THREE.TextureLoader();
        const photoCount = Math.min(files.length, 40);  // å‡å°‘ç…§ç‰‡æ•°é‡

        files.slice(0, photoCount).forEach((file, i) => {
            loader.load(URL.createObjectURL(file), (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                texture.minFilter = THREE.LinearMipmapLinearFilter;
                const aspect = texture.image.width / texture.image.height;
                const photoW = 0.8; const photoH = photoW / aspect;

                const borderMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(photoW+0.06, photoH+0.06, 0.04),
                    new THREE.MeshStandardMaterial({ color: currentBorderColor, roughness: 0.2, metalness: 0.8 })
                );
                const photoMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(photoW, photoH),
                    new THREE.MeshBasicMaterial({ map: texture })
                );
                photoMesh.position.z = 0.022;
                borderMesh.add(photoMesh);

                const treePos = getTreePos(i, photoCount);
                treePos.x *= 1.05; treePos.z *= 1.05;

                const cloudPos = getSafeZonePos();

                borderMesh.position.copy(treePos);
                borderMesh.lookAt(0, treePos.y, 0);
                photoGroup.add(borderMesh);

                photoInstances.push({
                    mesh: borderMesh,
                    posTree: treePos,
                    posCloud: cloudPos,
                    targetPos: treePos, currentPos: treePos.clone(),
                    baseScale: 1.0, currentScale: 1.0,
                    rotationTree: borderMesh.rotation.clone(),
                    rotVelocity: { x: (Math.random()-0.5)*0.03, y: (Math.random()-0.5)*0.03 }
                });
            });
        });
    }

    // --- äº¤äº’ä¸çŠ¶æ€ ---
    let state = {
        mode: 'TREE',
        pinching: false, pinchX: 0, pinchY: 0, pinchStabilityCounter: 0,
        lastColorSwitch: 0,
        lastHandX: 0.5, smoothHandX: 0.5, lastHandY: 0.5, smoothHandY: 0.5,
        isSwiping: false, rotVelocityX: 0, rotVelocityY: 0.002
    };

    // ç›¸æœºç›®æ ‡ä½ç½®ï¼ˆç”¨äºå¹³æ»‘è¿‡æ¸¡ï¼‰
    const cameraTarget = {
        x: 0,
        y: cameraY,
        z: cameraZ,
        fov: cameraFOV
    };

    function switchMode(newMode) {
        if (state.pinching || state.isSwiping) return;
        if (state.mode === newMode) return;
        state.mode = newMode;

        // ä¿®å¤ï¼šåˆ‡æ¢åˆ°åœ£è¯æ ‘æ¨¡å¼æ—¶ï¼Œé‡ç½®æ ‘ç»„æ—‹è½¬å’Œæ—‹è½¬é€Ÿåº¦ï¼Œç¡®ä¿åœ£è¯æ ‘ç»å¯¹æ­£
        if (newMode === 'TREE') {
            treeGroup.rotation.set(0, 0, 0);
            state.rotVelocityX = 0;
            state.rotVelocityY = 0.002; // ä¿æŒç¼“æ…¢æ—‹è½¬ï¼Œä½†ä»0å¼€å§‹
        }

        instances.forEach(inst => {
            if (newMode === 'TREE') inst.targetPos = inst.posTree;
            else if (newMode === 'CLOUD') inst.targetPos = inst.posCloud;
            else if (newMode === 'TEXT') {
                if (textPoints.length > 0 && textPoints[instances.indexOf(inst)]) {
                    inst.targetPos = textPoints[instances.indexOf(inst)];
                } else {
                    inst.targetPos = inst.posCloud;
                }
            }
        });

        photoInstances.forEach(inst => {
            if (newMode === 'TREE') inst.targetPos = inst.posTree;
            else if (newMode === 'CLOUD') inst.targetPos = inst.posCloud;
            else inst.targetPos = inst.posCloud;
        });

        // ç¤¼ç‰©ç›’åœ¨äº‘æ¨¡å¼è·Ÿéšæ˜Ÿäº‘æ•£å¼€ï¼Œåœ¨æ–‡å­—æ¨¡å¼éšè—
        gifts.forEach(g => {
            if (newMode === 'TREE') {
                g.targetPos.copy(g.posTree);
            } else if (newMode === 'CLOUD') {
                g.targetPos.copy(g.posCloud);
            } else if (newMode === 'TEXT') {
                g.targetPos.copy(g.posCloud);
            }
        });

        if (newMode === 'TEXT') {
            giftGroup.visible = false;
            updateTextModeCamera();
        } else {
            giftGroup.visible = true;
            // æ¢å¤é»˜è®¤ç›¸æœºä½ç½®
            cameraTarget.y = cameraY;
            cameraTarget.z = cameraZ;
            cameraTarget.fov = cameraFOV;
        }

        if (newMode === 'CLOUD') {
            topperState.posCloud.set((Math.random()-0.5)*25, (Math.random()-0.5)*15 + 10, (Math.random()-0.5)*15);  // å‡å°‘èŒƒå›´
            topperState.targetPos.copy(topperState.posCloud);
        } else if (newMode === 'TEXT') {
            // è°ƒæ•´ç›¸æœºä»¥ç¡®ä¿æ–‡å­—å®Œæ•´æ˜¾ç¤º
            updateTextModeCamera();
        } else {
            topperState.targetPos.copy(topperState.posTree);
        }
    }

    // æ›´æ–°æ–‡å­—æ¨¡å¼ä¸‹çš„ç›¸æœºä½ç½®
    function updateTextModeCamera() {
        const textConfig = getTextConfig();

        // æ ¹æ®æ–‡å­—é…ç½®åŠ¨æ€è®¡ç®—æ ‘é¡¶æ˜Ÿä½ç½®
        const merryTop = textConfig.y1 + textConfig.size * 0.5; // "Merry"é¡¶éƒ¨
        const spacing = textConfig.size * 0.5; // é—´è·
        const topperRadius = 1.5; // æ ‘é¡¶æ˜ŸåŠå¾„
        const topperY = merryTop + spacing + topperRadius;
        topperState.posText.set(0, topperY, 0);
        topperState.targetPos.copy(topperState.posText);
        topperState.currentPos.copy(topperState.targetPos);

        const textHeight = Math.abs(textConfig.y1 - textConfig.y2) + textConfig.size * 1.5;
        const aspect = window.innerWidth / window.innerHeight;

        // ç¡®å®šè¾¹è·è¦æ±‚
        const marginPx = textConfig.marginPx;
        const availableScreenWidth = window.innerWidth - marginPx * 2;

        // ä¼°ç®—æ–‡å­—åœ¨3Dç©ºé—´ä¸­çš„å®é™…å®½åº¦
        // "CHRISTMAS"æ˜¯9ä¸ªå­—æ¯ï¼Œè€ƒè™‘å­—æ¯é—´è·
        const letterWidth = textConfig.size * 0.65;
        const letterSpacing3D = textConfig.letterSpacing * textConfig.size * 2;
        const estimatedTextWidth3D = letterWidth * 9 + letterSpacing3D * 8;

        let targetY = 0;
        let targetFOV = cameraFOV;
        let targetZ;

        // iPhoneç«–å±ç‰¹æ®Šå¤„ç†
        if (textConfig.isiPhonePortrait) {
            targetFOV = 70;
            targetY = -textConfig.size * 0.4;
        } else if (textConfig.isIPadPortrait) {
            targetFOV = 70;
            targetY = -textConfig.size * 0.4;
        } else if (isMobile) {
            if (isLandscape) {
                targetFOV = 72;
            } else {
                targetFOV = 68;
            }
        } else if (isTablet) {
            targetFOV = 58;
        }

        // æ ¹æ®æ–‡å­—å®½åº¦å’Œè¾¹è·è¦æ±‚ç²¾ç¡®è®¡ç®—ç›¸æœºè·ç¦»
        const fovRad = THREE.MathUtils.degToRad(targetFOV);
        const tanHalfFov = Math.tan(fovRad / 2);
        const viewportWidthAtDistance1 = 2 * tanHalfFov * aspect;

        const calculatedZ = (estimatedTextWidth3D * window.innerWidth) / (viewportWidthAtDistance1 * availableScreenWidth);
        let baseZ = textHeight * 2.0;

        // iPhoneç«–å±ç‰¹æ®Šå¤„ç†
        if (textConfig.isiPhonePortrait) {
            targetZ = Math.max(calculatedZ, baseZ, textHeight * 2.8);
            targetZ = Math.min(targetZ, 65);  // å‡å°‘æœ€å¤§è·ç¦»
        } else if (textConfig.isIPadPortrait) {
            targetZ = Math.max(calculatedZ, baseZ, textHeight * 3.2);
            targetZ = Math.min(targetZ, 80);
        } else if (isMobile) {
            if (isLandscape) {
                targetZ = Math.max(calculatedZ, baseZ, textHeight * 2.5);
            } else {
                targetZ = Math.max(calculatedZ, baseZ, textHeight * 2.8);
            }
        } else if (isTablet) {
            targetZ = Math.max(calculatedZ, baseZ, textHeight * 2.2);
        } else {
            targetZ = Math.max(calculatedZ, baseZ);
        }

        // ç¡®ä¿æœ€å°è·ç¦»
        const minDistance = textConfig.isiPhonePortrait ? 50 : (textConfig.isIPadPortrait ? 55 : (isMobile ? 45 : 40));
        targetZ = Math.max(targetZ, minDistance);

        cameraTarget.y = targetY;
        cameraTarget.z = targetZ;
        cameraTarget.fov = targetFOV;
    }

    function switchColor() {
        if (state.pinching) return;
        const now = Date.now();
        if (now - state.lastColorSwitch > 1500) {
            currentPaletteIndex = (currentPaletteIndex + 1) % PALETTES.length;
            applyColors(currentPaletteIndex);
            state.lastColorSwitch = now;
            topperMat.emissiveIntensity = 3;
            setTimeout(() => topperMat.emissiveIntensity = 1, 200);
        }
    }

    // --- æ‰‹åŠ¿è¯†åˆ« ---
    const videoElement = document.getElementById('webcam_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');

    // ===== æ‘„åƒå¤´ & ç”»å¸ƒé€šç”¨åˆå§‹åŒ–ï¼ˆä¸»æµæœºå‹å…¼å®¹ï¼‰ =====
    // iOS ä¸Šéœ€è¦æ˜¾å¼è®¾ç½®è¿™äº›å±æ€§ï¼Œé¿å…å¼ºåˆ¶å…¨å±å’Œæ’­æ”¾å¤±è´¥
    videoElement.setAttribute('playsinline', 'true');
    videoElement.setAttribute('autoplay', 'true');
    videoElement.setAttribute('muted', 'true');
    videoElement.playsInline = true;
    videoElement.autoplay = true;
    videoElement.muted = true;

    // åŒæ­¥ canvas åƒç´ å°ºå¯¸åˆ°çœŸå®è§†é¢‘å°ºå¯¸ï¼Œé¿å…æ‹‰ä¼¸å’Œæ£€æµ‹åç§»
    videoElement.addEventListener('loadedmetadata', () => {
        const w = videoElement.videoWidth || 640;
        const h = videoElement.videoHeight || 480;
        canvasElement.width = w;
        canvasElement.height = h;
    });
    const statusText = document.getElementById('gesture-status');

    function detectGesture(landmarks) {
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const middleTip = landmarks[12];
        const ringTip = landmarks[16];
        const pinkyTip = landmarks[20];
        const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x-p2.x,2) + Math.pow(p1.y-p2.y,2));
        const isFingerOpen = (tipIdx, pipIdx) => landmarks[tipIdx].y < landmarks[pipIdx].y;

        if (dist(thumbTip, indexTip) < 0.05) return "PINCH";

        const idxOpen = isFingerOpen(8, 6);
        const midOpen = isFingerOpen(12, 10);
        const ringOpen = isFingerOpen(16, 14);
        const pinkyOpen = isFingerOpen(20, 18);

        if (idxOpen && midOpen && !ringOpen && !pinkyOpen) {
            if (dist(indexTip, middleTip) > 0.05) return "VICTORY";
        }
        if (idxOpen && !midOpen && !ringOpen && !pinkyOpen) return "POINTING";
        if (!idxOpen && !midOpen && !ringOpen && !pinkyOpen) return "FIST";

        let openCount = 0;
        if (idxOpen) openCount++; if (midOpen) openCount++; if (ringOpen) openCount++; if (pinkyOpen) openCount++;
        if (openCount >= 4) return "OPEN";
        return "NONE";
    }

    // Hands ä½¿ç”¨æœ¬åœ°èµ„æºç›®å½•ï¼šè¯·å°† @mediapipe/hands åŒ…å†…çš„æ¨¡å‹/wasm æ–‡ä»¶ä¹Ÿæ”¾åˆ° ./libs/mediapipe/hands/ ä¸‹
    const hands = new Hands({locateFile: (file) => `./libs/mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0,  // ä½¿ç”¨ç®€å•æ¨¡å‹æé«˜æ€§èƒ½
        // é™ä½ä¸€ç‚¹é˜ˆå€¼ï¼ŒçœŸæœºä¸Šæ›´å®¹æ˜“è¯†åˆ«åˆ°æ‰‹
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(results => {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1});

            state.smoothHandX = THREE.MathUtils.lerp(state.smoothHandX, landmarks[9].x, 0.2);
            state.smoothHandY = THREE.MathUtils.lerp(state.smoothHandY, landmarks[9].y, 0.2);

            const deltaX = state.smoothHandX - state.lastHandX;
            const deltaY = state.smoothHandY - state.lastHandY;
            state.lastHandX = state.smoothHandX; state.lastHandY = state.smoothHandY;

            const gesture = detectGesture(landmarks);
            state.pinchX = (landmarks[4].x + landmarks[8].x) - 1;
            state.pinchY = -((landmarks[4].y + landmarks[8].y) - 1);

            if (state.mode === 'CLOUD' && (Math.abs(deltaX) > 0.03 || Math.abs(deltaY) > 0.03)) {
                state.isSwiping = true;
                state.rotVelocityY += deltaX * 2.5;
                state.rotVelocityX += deltaY * 2.5;
                statusText.innerText = `Gesture: SWIPE (Rotating)`;
            } else {
                state.isSwiping = false;
            }

            if (gesture === "PINCH") {
                state.pinchStabilityCounter++;
                if (state.pinchStabilityCounter > 2) {
                    state.pinching = true;
                    statusText.innerText = "Gesture: PINCH (Locked)";
                }
            } else {
                state.pinchStabilityCounter = 0;
                state.pinching = false;
                if (!state.isSwiping) statusText.innerText = `Gesture: ${gesture}`;
            }

            if (!state.pinching && !state.isSwiping) {
                switch(gesture) {
                    case "OPEN": switchMode('CLOUD'); break;
                    case "FIST": switchMode('TREE'); break;
                    case "VICTORY": switchColor(); break;
                    case "POINTING": switchMode('TEXT'); break;
                }
            }
        } else {
            statusText.innerText = "No Hand";
            state.pinching = false; state.isSwiping = false;
        }
        canvasCtx.restore();
    });

    // ===== ç»Ÿä¸€æ‘„åƒå¤´å¯åŠ¨é€»è¾‘ï¼šæ ‡å‡† getUserMediaï¼Œå…¼å®¹ä¸»æµæµè§ˆå™¨(iOS Safari/Chrome, Android, æ¡Œé¢) =====
    let cameraStream = null;
    let handLoopRunning = false;

    async function startHandLoop() {
        if (handLoopRunning) return;
        handLoopRunning = true;
        const loop = async () => {
            // ç­‰å¾…è§†é¢‘çœŸçš„æœ‰ç”»é¢å†é€å…¥æ¨¡å‹
            if (videoElement.readyState >= 2) {
                try {
                    await hands.send({ image: videoElement });
                } catch (err) {
                    console.warn('hands.send error', err);
                }
            }
            if (handLoopRunning) requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
    }

    async function startCamera() {
        // è¯¦ç»†çš„å…¼å®¹æ€§æ£€æŸ¥å’Œé”™è¯¯ä¿¡æ¯
        console.log('Browser compatibility check:', {
            navigator_mediaDevices: !!navigator.mediaDevices,
            navigator_getUserMedia: !!navigator.getUserMedia,
            navigator_mediaDevices_getUserMedia: !!navigator.mediaDevices?.getUserMedia,
            protocol: window.location.protocol
        });

        // å…¼å®¹å¤šç§æµè§ˆå™¨APIå½¢å¼ - ä¼˜åŒ–iPadæ”¯æŒ
        let getUserMedia;

        // å·²ç»é€šè¿‡detectDeviceTypeæ£€æµ‹è¿‡ï¼Œè¿™é‡Œç›´æ¥ä½¿ç”¨
        console.log('Device detection:', deviceInfo);

        // è¯¦ç»†è®°å½•æ‰€æœ‰å¯èƒ½çš„APIå¯ç”¨æ€§
        console.log('API availability check:', {
            navigator_mediaDevices: !!navigator.mediaDevices,
            navigator_mediaDevices_getUserMedia: typeof navigator.mediaDevices?.getUserMedia === 'function',
            navigator_getUserMedia: typeof navigator.getUserMedia === 'function',
            navigator_webkitGetUserMedia: typeof navigator.webkitGetUserMedia === 'function',
            navigator_mozGetUserMedia: typeof navigator.mozGetUserMedia === 'function',
            navigator_msGetUserMedia: typeof navigator.msGetUserMedia === 'function'
        });

        // æ£€æŸ¥åè®®æ˜¯å¦ä¸ºHTTPSï¼ˆgetUserMediaåœ¨élocalhostçš„HTTPç¯å¢ƒä¸‹å¯èƒ½è¢«ç¦ç”¨ï¼‰
        const isSecureContext = window.isSecureContext;
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        const isHttp = window.location.protocol === 'http:';
        console.log('Protocol check:', { isSecureContext, isLocalhost, isHttp });

        // å¦‚æœæ˜¯HTTPåè®®ä¸”ä¸æ˜¯localhostï¼Œå¯èƒ½æ˜¯getUserMediaä¸å¯ç”¨çš„åŸå› 
        if (isHttp && !isLocalhost) {
            console.warn('Warning: getUserMedia may be blocked in non-HTTPS, non-localhost environments');
        }

        // é’ˆå¯¹iPadçš„ç‰¹æ®Šå¤„ç†ï¼šä¼˜å…ˆä½¿ç”¨webkitGetUserMedia
        if (isIPad) {
            console.log('iPad detected, applying special handling');
            // å¯¹äºiPadï¼ŒwebkitGetUserMediaæ˜¯æœ€å¯é çš„é€‰æ‹©
            if (typeof navigator.webkitGetUserMedia === 'function') {
                getUserMedia = navigator.webkitGetUserMedia;
                console.log('Using iPad-specific webkitGetUserMedia');
            } else if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                getUserMedia = navigator.mediaDevices.getUserMedia;
                console.log('iPad fallback to standard navigator.mediaDevices.getUserMedia');
            } else if (typeof navigator.getUserMedia === 'function') {
                getUserMedia = navigator.getUserMedia;
                console.log('iPad fallback to navigator.getUserMedia');
            }
        }
        // éiPadè®¾å¤‡çš„æ ‡å‡†æ£€æµ‹
        else {
            // é¦–å…ˆå°è¯•æ ‡å‡†çš„navigator.mediaDevices.getUserMedia
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                getUserMedia = navigator.mediaDevices.getUserMedia;
                console.log('Using standard navigator.mediaDevices.getUserMedia');
            }
            // ç„¶åå°è¯•å„ç§å‰ç¼€ç‰ˆæœ¬
            else {
                getUserMedia = navigator.getUserMedia ||
                    navigator.webkitGetUserMedia ||
                    navigator.mozGetUserMedia ||
                    navigator.msGetUserMedia;
                console.log('Using legacy getUserMedia API:', { getUserMedia });
            }
        }

        // æœ€åçš„å…œåº•æ£€æŸ¥
        if (!getUserMedia) {
            console.warn('Primary getUserMedia not found, checking all available APIs again...');
            getUserMedia = navigator.mediaDevices?.getUserMedia ||
                navigator.webkitGetUserMedia ||
                navigator.getUserMedia ||
                navigator.mozGetUserMedia ||
                navigator.msGetUserMedia;
            console.log('Final getUserMedia check result:', { getUserMedia });
        }

        // å¯¹äºiPadï¼Œå³ä½¿getUserMediaçœ‹èµ·æ¥å¯ç”¨ï¼Œä¹Ÿå¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†
        if (!getUserMedia) {
            console.error('getUserMedia not supported on this browser.');

            // æ£€æŸ¥æ˜¯å¦æ˜¯HTTPåè®®å¯¼è‡´çš„é—®é¢˜
            if (isHttp && !isLocalhost) {
                console.error('getUserMedia likely blocked due to HTTP protocol. Modern browsers require HTTPS for camera access.');
                statusText.innerText = 'Camera Not Supported (HTTPS Required)';
            } else {
                statusText.innerText = 'Camera Not Supported';
            }
            return;
        }

        // å°è¯•ä¼˜å…ˆä½¿ç”¨å‰ç½®æ‘„åƒå¤´ï¼›å¦‚æœå¤±è´¥ï¼Œå†é€€å›å®½æ¾çº¦æŸ
        // é’ˆå¯¹iPadä¼˜åŒ–çº¦æŸæ¡ä»¶
        const constraintsList = [
            {
                // åŸºç¡€å‰ç½®æ‘„åƒå¤´é…ç½®ï¼Œé€‚åˆå¤§å¤šæ•°è®¾å¤‡
                video: {
                    facingMode: { ideal: 'user' },
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    frameRate: { ideal: 30, max: 30 }
                }
            },
            {
                // ä¸“é—¨ä¸ºiPadä¼˜åŒ–çš„å‰ç½®æ‘„åƒå¤´é…ç½®
                video: {
                    facingMode: { ideal: 'user' },
                    width: { ideal: 480 }, // æ›´ä½çš„åˆ†è¾¨ç‡ï¼Œå‡å°‘iPadçš„å¤„ç†è´Ÿæ‹…
                    height: { ideal: 360 },
                    frameRate: { ideal: 15, max: 30 } // æ›´å®½æ¾çš„å¸§ç‡é™åˆ¶
                }
            },
            {
                // å®½æ¾çš„å‰ç½®æ‘„åƒå¤´é…ç½®ï¼Œä¸æŒ‡å®šåˆ†è¾¨ç‡å’Œå¸§ç‡
                video: {
                    facingMode: 'user'
                }
            },
            {
                // å®Œå…¨å®½æ¾çš„çº¦æŸï¼Œä¸æŒ‡å®šæ‘„åƒå¤´æ–¹å‘
                video: {
                    facingMode: 'environment' // å°è¯•åç½®æ‘„åƒå¤´
                }
            },
            {
                // æœ€ç»ˆçš„å…œåº•çº¦æŸï¼Œåªè¦æ±‚æœ‰è§†é¢‘
                video: true
            }
        ];

        for (let i = 0; i < constraintsList.length; i++) {
            try {
                let stream;
                console.log(`=== Attempt ${i+1}/${constraintsList.length} ===`);
                console.log('Trying to get camera stream with constraints:', JSON.stringify(constraintsList[i], null, 2));

                // ä½¿ç”¨ç»Ÿä¸€çš„æ–¹å¼è°ƒç”¨getUserMediaï¼Œä¼˜å…ˆä½¿ç”¨ç°ä»£API
                if (navigator.mediaDevices) {
                    // ç°ä»£æµè§ˆå™¨API - åŒ…æ‹¬iPad Safari
                    console.log('Using navigator.mediaDevices.getUserMedia');
                    stream = await navigator.mediaDevices.getUserMedia(constraintsList[i]);
                } else if (getUserMedia) {
                    // æ—§ç‰ˆæµè§ˆå™¨APIï¼ˆå›è°ƒå½¢å¼ï¼‰
                    console.log('Using legacy getUserMedia API');
                    stream = await new Promise((resolve, reject) => {
                        getUserMedia(constraintsList[i], resolve, reject);
                    });
                } else {
                    throw new Error('No getUserMedia implementation found');
                }

                console.log('âœ… Successfully obtained camera stream!');
                console.log('Stream details:', {
                    id: stream.id,
                    active: stream.active,
                    tracks: stream.getTracks().map(track => ({
                        kind: track.kind,
                        enabled: track.enabled,
                        label: track.label
                    }))
                });
                cameraStream = stream;

                // ä¸ºiPad Safariè®¾ç½®è§†é¢‘æº
                videoElement.srcObject = stream;

                // ç¡®ä¿è§†é¢‘å…ƒç´ å±æ€§æ­£ç¡®è®¾ç½®
                videoElement.playsInline = true;
                videoElement.autoplay = true;
                videoElement.muted = true;
                videoElement.controls = false;

                // iOSéœ€è¦ç”¨æˆ·æ‰‹åŠ¿åplayï¼›è¿™é‡Œåœ¨æŒ‰é’®ç‚¹å‡»åè°ƒç”¨ï¼Œç¬¦åˆè¦æ±‚
                // ä½¿ç”¨æ›´ç¨³å¥çš„æ’­æ”¾å¤„ç†ï¼Œä¸“é—¨é’ˆå¯¹iOS/iPadä¼˜åŒ–
                try {
                    console.log('Attempting to play video...');
                    await videoElement.play();
                    console.log('Video playback started successfully');
                } catch (e) {
                    console.warn('First video.play attempt failed, trying alternate approach:', e);

                    // å°è¯•ç­‰å¾…è§†é¢‘åŠ è½½å®Œæˆåå†æ’­æ”¾
                    videoElement.addEventListener('canplaythrough', async () => {
                        try {
                            await videoElement.play();
                            console.log('Video playback started after canplaythrough event');
                        } catch (err) {
                            console.error('Second video.play attempt failed:', err);

                            // ç»ˆæå°è¯•ï¼šç›´æ¥è°ƒç”¨play()ï¼Œä¸ç­‰å¾…promise
                            setTimeout(() => {
                                videoElement.play().catch(finalErr => {
                                    console.error('Final video.play attempt failed:', finalErr);
                                });
                            }, 100);
                        }
                    }, { once: true });

                    // æ‰‹åŠ¨åŠ è½½è§†é¢‘
                    videoElement.load();
                }

                // å¯åŠ¨æ‰‹åŠ¿è¯†åˆ«
                startHandLoop();
                return;
            } catch (err) {
                console.error(`âŒ Failed to get camera stream with constraints ${i}:`, {
                    name: err.name,
                    message: err.message,
                    constraint: JSON.stringify(constraintsList[i], null, 2)
                });

                // æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                if (i === constraintsList.length - 1) {
                    console.error('âŒ All camera constraints failed! Final error details:', {
                        name: err.name,
                        message: err.message,
                        stack: err.stack,
                        isIPad
                    });

                    // é’ˆå¯¹ä¸åŒçš„é”™è¯¯ç±»å‹æ˜¾ç¤ºä¸åŒçš„æç¤º
                    if (err.name === 'NotAllowedError') {
                        statusText.innerText = 'Camera Permission Denied';
                    } else if (err.name === 'NotFoundError') {
                        statusText.innerText = 'No Camera Found';
                    } else if (err.name === 'NotReadableError') {
                        statusText.innerText = 'Camera Busy';
                    } else if (err.name === 'OverconstrainedError') {
                        statusText.innerText = 'Camera Constraints Not Met';
                    } else {
                        statusText.innerText = 'Camera Error: ' + err.name;
                    }
                }
            }
        }
    }

    // ä¿®æ”¹å¼€å§‹æŒ‰é’®ç‚¹å‡»äº‹ä»¶ï¼Œéšè—UIå®¹å™¨å’Œæ‘„åƒå¤´é¢„è§ˆ
    document.getElementById('start-btn').addEventListener('click', () => {
        document.querySelector('.btn-group').style.display = 'none';
        document.getElementById('ui-container').style.display = 'none';  // éšè—å·¦ä¸Šè§’çš„æ‰‹åŠ¿æ“ä½œè¯´æ˜
        document.getElementById('cam-container').style.display = 'none'; // éšè—å³ä¸‹è§’çš„æ‘„åƒå¤´é¢„è§ˆ
        playMusic(0);
        startCamera();
    });

    window.addEventListener('mousedown', () => switchMode('TREE'));
    window.addEventListener('mouseup', () => switchMode('CLOUD'));

    // ç§»åŠ¨ç«¯åŒå‡»åˆ‡æ¢å…¨å±ï¼ˆè¿›å…¥ / é€€å‡ºï¼‰
    let lastTapTime = 0;
    let tapCount = 0;
    window.addEventListener('touchstart', (e) => {
        const currentTime = Date.now();
        const tapLength = currentTime - lastTapTime;

        if (tapCount === 0) {
            tapCount = 1;
        } else if (tapCount === 1 && tapLength < 300) {
            // åŒå‡»æ£€æµ‹ï¼šåˆ‡æ¢å…¨å±çŠ¶æ€
            tapCount = 0;
            toggleFullscreen();
        } else {
            tapCount = 0;
        }

        lastTapTime = currentTime;

        // é‡ç½®è®¡æ•°å™¨
        setTimeout(() => {
            tapCount = 0;
        }, 300);
    });

    const clock = new THREE.Clock();
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false; controls.enableDamping = true;
    const tempV = new THREE.Vector3();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        // ========== æ€§èƒ½ä¼˜åŒ–ï¼šç®€åŒ–ä¸€äº›åŠ¨ç”»è®¡ç®— ==========
        if (state.mode === 'TEXT') {
            state.rotVelocityX = 0; state.rotVelocityY = 0;
            treeGroup.rotation.x = THREE.MathUtils.lerp(treeGroup.rotation.x, 0, 0.1);
            treeGroup.rotation.y = THREE.MathUtils.lerp(treeGroup.rotation.y, 0, 0.1);
            treeGroup.rotation.z = THREE.MathUtils.lerp(treeGroup.rotation.z, 0, 0.1);
        } else if (state.mode === 'TREE') {
            // ä¿®å¤ï¼šåœ¨åœ£è¯æ ‘æ¨¡å¼ä¸‹ï¼Œé™åˆ¶æ—‹è½¬é€Ÿåº¦ï¼Œç¡®ä¿åœ£è¯æ ‘ä¿æŒåŸºæœ¬æ­£å‘
            state.rotVelocityY = THREE.MathUtils.clamp(state.rotVelocityY, -0.03, 0.03); // å‡å°æœ€å¤§æ—‹è½¬é€Ÿåº¦
            state.rotVelocityX = THREE.MathUtils.clamp(state.rotVelocityX, -0.02, 0.02);
            let baseSpeedY = 0.002; // åœ£è¯æ ‘æ¨¡å¼çš„åŸºç¡€æ—‹è½¬é€Ÿåº¦
            state.rotVelocityY = THREE.MathUtils.lerp(state.rotVelocityY, baseSpeedY, 0.02); // ç¼“æ…¢æ¢å¤åˆ°åŸºç¡€é€Ÿåº¦
            state.rotVelocityX = THREE.MathUtils.lerp(state.rotVelocityX, 0, 0.05);
            treeGroup.rotation.y += state.rotVelocityY;
            treeGroup.rotation.x += state.rotVelocityX;
            treeGroup.rotation.x = THREE.MathUtils.clamp(treeGroup.rotation.x, -0.2, 0.2); // å‡å°‘æœ€å¤§å€¾æ–œè§’åº¦
        } else {
            // æ˜Ÿäº‘æ¨¡å¼ä¿æŒåŸæœ‰é€»è¾‘
            state.rotVelocityY = THREE.MathUtils.clamp(state.rotVelocityY, -0.15, 0.15);
            state.rotVelocityX = THREE.MathUtils.clamp(state.rotVelocityX, -0.10, 0.10);
            let baseSpeedY = 0.0005;
            state.rotVelocityY = THREE.MathUtils.lerp(state.rotVelocityY, baseSpeedY, 0.03);
            state.rotVelocityX = THREE.MathUtils.lerp(state.rotVelocityX, 0, 0.05);
            treeGroup.rotation.y += state.rotVelocityY;
            treeGroup.rotation.x += state.rotVelocityX;
            treeGroup.rotation.x = THREE.MathUtils.clamp(treeGroup.rotation.x, -0.5, 0.5);
        }
        photoGroup.rotation.copy(treeGroup.rotation);
        decorGroup.rotation.y = treeGroup.rotation.y;
        // Swipe æ—¶ç¤¼ç‰©ç›’ä¹Ÿä¸æ ‘ä¸€èµ·æ—‹è½¬
        giftGroup.rotation.copy(treeGroup.rotation);

        // --- ç¤¼ç‰©ç›’è½»å¾®å‘¼å¸/æ‘‡æ‘† ---
        if (gifts.length > 0) {
            gifts.forEach((g) => {
                // è·Ÿéšç›®æ ‡ä½ç½®åœ¨ TREE/CLOUD é—´ç§»åŠ¨ï¼Œå½¢æˆ"è·Ÿéšæ˜Ÿäº‘"çš„æ•ˆæœ
                const moveSpeedGift = (state.mode === 'CLOUD') ? CONFIG.floatSpeed : CONFIG.restoreSpeed;
                g.currentPos.lerp(g.targetPos, moveSpeedGift);

                // è½»å¾®ä¸Šä¸‹å‘¼å¸
                const wobbleAmp = (state.mode === 'TREE') ? 0.12 : 0.04;
                const wobbleY = Math.sin(time * 1.4 + g.wobblePhase) * wobbleAmp;

                g.mesh.position.set(
                    g.currentPos.x,
                    g.currentPos.y + wobbleY,
                    g.currentPos.z
                );

                if (state.mode === 'TREE') {
                    g.mesh.rotation.y += 0.003;
                }
            });
        }

        // --- Topper åŠ¨ç”» ---
        const topperSpeed = (state.mode === 'CLOUD') ? 0.12 : 0.18;
        topperState.currentPos.lerp(topperState.targetPos, topperSpeed);
        if (state.mode !== 'TREE') {
            topperState.currentPos.y += Math.sin(time * 2) * 0.02;
            topperMesh.rotation.y += 0.02;
            topperMesh.rotation.z = Math.sin(time) * 0.1;
        } else {
            topperMesh.rotation.y += 0.01;
            topperMesh.rotation.z = 0;
        }
        topperMesh.position.copy(topperState.currentPos);

        // --- ç›¸æœºä½ç½®å¹³æ»‘è¿‡æ¸¡ï¼ˆç•¥å¾®åŠ å¿«è¿‡æ¸¡é€Ÿåº¦ï¼‰ ---
        camera.position.x = THREE.MathUtils.lerp(camera.position.x, cameraTarget.x, 0.08);
        camera.position.y = THREE.MathUtils.lerp(camera.position.y, cameraTarget.y, 0.08);
        camera.position.z = THREE.MathUtils.lerp(camera.position.z, cameraTarget.z, 0.08);
        camera.fov = THREE.MathUtils.lerp(camera.fov, cameraTarget.fov, 0.08);
        camera.updateProjectionMatrix();

        // --- è£…é¥°åŠ¨ç”» ---
        if(state.mode === 'TREE') {
            spiralMat.opacity = THREE.MathUtils.lerp(spiralMat.opacity, 0.6, 0.05);
            floorRing.material.opacity = THREE.MathUtils.lerp(floorRing.material.opacity, 0.4, 0.05);

            // æ˜Ÿå°˜ç³»ç»Ÿæ·¡å…¥
            galaxyMat.opacity = THREE.MathUtils.lerp(galaxyMat.opacity, 0.8, 0.02);
            lineMat.opacity = THREE.MathUtils.lerp(lineMat.opacity, 0.3, 0.02);
        } else {
            spiralMat.opacity = THREE.MathUtils.lerp(spiralMat.opacity, 0, 0.1);
            floorRing.material.opacity = THREE.MathUtils.lerp(floorRing.material.opacity, 0, 0.1);

            // æ˜Ÿå°˜ç³»ç»Ÿæ·¡å‡º
            galaxyMat.opacity = THREE.MathUtils.lerp(galaxyMat.opacity, 0, 0.05);
            lineMat.opacity = THREE.MathUtils.lerp(lineMat.opacity, 0, 0.05);
        }

        // æ›´æ–°æ˜Ÿå°˜æ—‹è½¬
        galaxySystem.rotation.y += 0.001;

        // æ›´æ–°æµæ˜Ÿé›¨
        if(lineMat.opacity > 0.01) {
            const positions = shootingLines.geometry.attributes.position.array;
            for(let i=0; i<lineCount; i++) {
                positions[i*6 + 2] -= lineSpeed[i]; // Head Z
                positions[i*6 + 5] -= lineSpeed[i]; // Tail Z

                if(positions[i*6 + 2] < -120) {  // å‡å°‘é‡ç½®è·ç¦»
                    const newZ = 120;
                    const newX = (Math.random()-0.5) * 250;
                    const newY = (Math.random()-0.5) * 250;
                    positions[i*6] = newX; positions[i*6+1] = newY; positions[i*6+2] = newZ;
                    positions[i*6+3] = newX; positions[i*6+4] = newY - 5; positions[i*6+5] = newZ + 10;
                }
            }
            shootingLines.geometry.attributes.position.needsUpdate = true;
        }

        if(spiralMat.opacity > 0.01) {
            const spiralPosArr = spiralGeo.attributes.position.array;
            // ========== æ€§èƒ½ä¼˜åŒ–ï¼šç®€åŒ–èºæ—‹åŠ¨ç”»è®¡ç®— ==========
            for(let i=0; i<spiralCount; i+=2) {  // è·³è¿‡ä¸€äº›ç²’å­è®¡ç®—
                const ratio = i / spiralCount;
                const angle = ratio * Math.PI * 8 + time * 0.5;
                const radius = 9 - ratio * 8;
                const y = ratio * CONFIG.height - CONFIG.height/2;
                const offset = (i%2===0) ? 0 : Math.PI;
                spiralPosArr[i*3] = Math.cos(angle + offset) * radius;
                spiralPosArr[i*3+1] = y;
                spiralPosArr[i*3+2] = Math.sin(angle + offset) * radius;

                // å¤åˆ¶åˆ°ä¸‹ä¸€ä¸ªç²’å­ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if(i+1 < spiralCount) {
                    spiralPosArr[(i+1)*3] = spiralPosArr[i*3];
                    spiralPosArr[(i+1)*3+1] = spiralPosArr[i*3+1];
                    spiralPosArr[(i+1)*3+2] = spiralPosArr[i*3+2];
                }
            }
            spiralGeo.attributes.position.needsUpdate = true;
            const s = 1 + Math.sin(time * 2) * 0.05;
            floorRing.scale.set(s, s, s);
        }

        // --- é›ªèŠ±ç³»ç»Ÿ ---
        const isTextMode = state.mode === 'TEXT';
        if (isTextMode) {
            snowMat.opacity = THREE.MathUtils.lerp(snowMat.opacity, 0.9, 0.02);
            textSnowMat.opacity = THREE.MathUtils.lerp(textSnowMat.opacity, 1.2, 0.03);
        } else {
            snowMat.opacity = THREE.MathUtils.lerp(snowMat.opacity, 0, 0.05);
            textSnowMat.opacity = THREE.MathUtils.lerp(textSnowMat.opacity, 0, 0.06);
        }

        if (snowMat.opacity > 0.01) {
            const positions = snowGeo.attributes.position.array;
            // ========== æ€§èƒ½ä¼˜åŒ–ï¼šç®€åŒ–é›ªèŠ±åŠ¨ç”»è®¡ç®— ==========
            for(let i=0; i<snowCount; i+=2) {  // è·³è¿‡ä¸€äº›ç²’å­è®¡ç®—
                positions[i*3+1] += snowVel[i].y;
                positions[i*3] += Math.sin(time + positions[i*3+1]*0.05) * 0.02;
                if (positions[i*3+1] < -30) {
                    positions[i*3+1] = 30;
                    positions[i*3] = (Math.random()-0.5) * 80;
                    positions[i*3+2] = (Math.random()-0.5) * 40 + 20;
                }

                // å¤åˆ¶åˆ°ä¸‹ä¸€ä¸ªç²’å­ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if(i+1 < snowCount) {
                    positions[(i+1)*3] = positions[i*3];
                    positions[(i+1)*3+1] = positions[i*3+1];
                    positions[(i+1)*3+2] = positions[i*3+2];
                }
            }
            snowGeo.attributes.position.needsUpdate = true;
        }

        if (textSnowMat.opacity > 0.01) {
            const positions = textSnowGeo.attributes.position.array;
            // ========== æ€§èƒ½ä¼˜åŒ–ï¼šç®€åŒ–æ–‡å­—æ¨¡å¼é›ªèŠ±åŠ¨ç”»è®¡ç®— ==========
            for (let i = 0; i < textSnowCount; i+=2) {  // è·³è¿‡ä¸€äº›ç²’å­è®¡ç®—
                positions[i*3]   += textSnowVel[i].x;
                positions[i*3+1] += textSnowVel[i].y;
                positions[i*3+2] += textSnowVel[i].z;
                // å¾ªç¯ä¸‹è½
                if (positions[i*3+1] < -20) {
                    positions[i*3]   = (Math.random()-0.5) * 60;
                    positions[i*3+1] = 25 + Math.random() * 40;
                    positions[i*3+2] = (Math.random()-0.5) * 35;
                }

                // å¤åˆ¶åˆ°ä¸‹ä¸€ä¸ªç²’å­ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if(i+1 < textSnowCount) {
                    positions[(i+1)*3] = positions[i*3];
                    positions[(i+1)*3+1] = positions[i*3+1];
                    positions[(i+1)*3+2] = positions[i*3+2];
                }
            }
            textSnowGeo.attributes.position.needsUpdate = true;
        }

        // --- ç²’å­åŠ¨ç”» ---
        const isCloud = state.mode === 'CLOUD';
        const moveSpeed = isCloud ? CONFIG.floatSpeed : CONFIG.restoreSpeed;

        instances.forEach(inst => {
            inst.currentPos.lerp(inst.targetPos, moveSpeed);
            inst.currentPos.y += Math.sin(time*2 + inst.meshIndex)*0.01;

            if(state.mode === 'TEXT') {
                inst.rotation.x *= 0.9; inst.rotation.y *= 0.9;
            } else if(isCloud) {
                inst.rotation.x += inst.rotSpeed.x; inst.rotation.y += inst.rotSpeed.y;
            } else {
                inst.rotation.x += inst.rotSpeed.x * 0.1;
            }

            dummy.position.copy(inst.currentPos);
            dummy.rotation.set(inst.rotation.x, inst.rotation.y, inst.rotation.z);
            dummy.scale.setScalar(1);
            dummy.updateMatrix();
            const mesh = inst.type === 'sphere' ? sphereMesh : cubeMesh;
            mesh.setMatrixAt(inst.meshIndex, dummy.matrix);
        });
        sphereMesh.instanceMatrix.needsUpdate = true;
        cubeMesh.instanceMatrix.needsUpdate = true;

        // --- ç…§ç‰‡åŠ¨ç”» ---
        let closestIdx = -1; let minDist = Infinity;
        if (state.pinching && state.mode === 'CLOUD' && photoInstances.length > 0) {
            photoInstances.forEach((inst, i) => {
                inst.mesh.getWorldPosition(tempV);
                tempV.project(camera);
                if (tempV.z < 1) {
                    const dist = Math.sqrt(Math.pow(tempV.x - state.pinchX, 2) + Math.pow(tempV.y - state.pinchY, 2));
                    if (dist < minDist) { minDist = dist; closestIdx = i; }
                }
            });
        }

        photoInstances.forEach((inst, i) => {
            inst.currentPos.lerp(inst.targetPos, moveSpeed);
            if(isCloud) {
                inst.currentPos.y += Math.sin(time*1.5 + i)*0.01;
                inst.mesh.rotation.x += inst.rotVelocity.x; inst.mesh.rotation.y += inst.rotVelocity.y;
            } else {
                inst.currentPos.y += Math.sin(time*1.5 + i)*0.01;
                inst.mesh.rotation.x = THREE.MathUtils.lerp(inst.mesh.rotation.x, inst.rotationTree.x, 0.1);
                inst.mesh.rotation.y = THREE.MathUtils.lerp(inst.mesh.rotation.y, inst.rotationTree.y, 0.1);
                inst.mesh.rotation.z = THREE.MathUtils.lerp(inst.mesh.rotation.z, inst.rotationTree.z, 0.1);
            }
            inst.mesh.position.copy(inst.currentPos);

            const isSelected = state.pinching && i === closestIdx;
            let targetScale = 0;
            if (state.mode === 'CLOUD') {
                targetScale = isSelected ? 20.0 : inst.baseScale;  // å‡å°‘æ”¾å¤§å€æ•°
                inst.mesh.visible = true;
            } else {
                targetScale = 0;
            }
            inst.currentScale = THREE.MathUtils.lerp(inst.currentScale, targetScale, 0.1);
            if (state.mode !== 'CLOUD' && inst.currentScale < 0.01) inst.mesh.visible = false;
            inst.mesh.scale.setScalar(inst.currentScale);

            const photoMesh = inst.mesh.children[0];
            const borderMat = inst.mesh.material;
            const photoMat = photoMesh ? photoMesh.material : null;

            if (isSelected && state.mode === 'CLOUD') {
                inst.mesh.lookAt(camera.position);
                inst.mesh.renderOrder = 9999;
                if(photoMesh) photoMesh.renderOrder = 10000;
                if(borderMat) { borderMat.depthTest = false; borderMat.depthWrite = false; }
                if(photoMat) { photoMat.depthTest = false; photoMat.depthWrite = false; photoMat.fog = false; photoMat.toneMapped = false; }
            } else {
                inst.mesh.renderOrder = 0;
                if(photoMesh) photoMesh.renderOrder = 0;
                if(borderMat) { borderMat.depthTest = true; borderMat.depthWrite = true; }
                if(photoMat) { photoMat.depthTest = true; photoMat.depthWrite = true; photoMat.fog = true; photoMat.toneMapped = true; }
            }
        });

        controls.update();
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        // é‡æ–°æ£€æµ‹è®¾å¤‡ç±»å‹
        const newDeviceInfo = detectDeviceType();
        const newIsMobile = newDeviceInfo.isMobile;
        const newIsTablet = newDeviceInfo.isTablet;
        const newIsLandscape = newDeviceInfo.isLandscape;
        const newIsIPad = newDeviceInfo.isIPad;

        // æ›´æ–°ç›¸æœºå‚æ•°
        let newFOV = 45;
        let newZ = 55;
        let newY = 5;

        if (newIsMobile) {
            if (newIsLandscape) {
                newFOV = 60;
                newZ = 45;
                newY = 3;
            } else {
                newFOV = 55;
                newZ = 50;
                newY = 4;
            }
        } else if (newIsTablet) {
            // iPadæ¨ªå±ç‰¹æ®Šå¤„ç†
            if (newIsIPad && newIsLandscape) {
                newFOV = 52;
                newZ = 48;
                newY = 4;
            } else {
                newFOV = 50;
                newZ = 52;
                newY = 4.5;
            }
        }

        // å¦‚æœå­—ä½“å·²åŠ è½½ï¼Œé‡æ–°åˆ›å»ºæ–‡å­—å‡ ä½•ä½“
        if (loadedFont) {
            createTextGeometry();
        }

        // å¦‚æœå½“å‰æ˜¯æ–‡å­—æ¨¡å¼ï¼Œæ ¹æ®æ–°çš„å±å¹•å°ºå¯¸é‡æ–°è®¡ç®—ç›¸æœºä½ç½®å’Œæ ‘é¡¶æ˜Ÿä½ç½®
        if (state.mode === 'TEXT') {
            updateTextModeCamera();
        } else {
            // éæ–‡å­—æ¨¡å¼ï¼Œä½¿ç”¨é»˜è®¤ç›¸æœºä½ç½®
            cameraTarget.y = newY;
            cameraTarget.z = newZ;
            cameraTarget.fov = newFOV;
        }

        // æ›´æ–°å®ä¾‹çš„æ–‡å­—ä½ç½®
        updateTextModePositions();

        camera.fov = cameraTarget.fov;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.position.set(0, cameraTarget.y, cameraTarget.z);
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    animate();
</script>
</body>
</html>